/* tslint:disable */
/* eslint-disable */

// ######################################## THIS FILE WAS GENERATED BY MONGOOSE-TSGEN ######################################## //

// NOTE: ANY CHANGES MADE WILL BE OVERWRITTEN ON SUBSEQUENT EXECUTIONS OF MONGOOSE-TSGEN.

import mongoose from "mongoose"

/**
 * Lean version of AccountabilityPartnershipDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `AccountabilityPartnershipDocument.toObject()`. To avoid conflicts with model names, use the type alias `AccountabilityPartnershipObject`.
 * ```
 * const accountabilitypartnershipObject = accountabilitypartnership.toObject();
 * ```
 */
export type AccountabilityPartnership = {
  user1: User["_id"] | User
  user2: User["_id"] | User
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of AccountabilityPartnershipDocument (type alias of `AccountabilityPartnership`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { AccountabilityPartnership } from "../models"
 * import { AccountabilityPartnershipObject } from "../interfaces/mongoose.gen.ts"
 *
 * const accountabilitypartnershipObject: AccountabilityPartnershipObject = accountabilitypartnership.toObject();
 * ```
 */
export type AccountabilityPartnershipObject = AccountabilityPartnership

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type AccountabilityPartnershipQuery = mongoose.Query<
  any,
  AccountabilityPartnershipDocument,
  AccountabilityPartnershipQueries
> &
  AccountabilityPartnershipQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `AccountabilityPartnershipSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type AccountabilityPartnershipQueries = {}

export type AccountabilityPartnershipMethods = {}

export type AccountabilityPartnershipStatics = {
  findBetweenUsers: (
    this: AccountabilityPartnershipModel,
    u1: string,
    u2: string
  ) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const AccountabilityPartnership = mongoose.model<AccountabilityPartnershipDocument, AccountabilityPartnershipModel>("AccountabilityPartnership", AccountabilityPartnershipSchema);
 * ```
 */
export type AccountabilityPartnershipModel = mongoose.Model<
  AccountabilityPartnershipDocument,
  AccountabilityPartnershipQueries
> &
  AccountabilityPartnershipStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new AccountabilityPartnership schema instances:
 * ```
 * const AccountabilityPartnershipSchema: AccountabilityPartnershipSchema = new mongoose.Schema({ ... })
 * ```
 */
export type AccountabilityPartnershipSchema = mongoose.Schema<
  AccountabilityPartnershipDocument,
  AccountabilityPartnershipModel,
  AccountabilityPartnershipMethods,
  AccountabilityPartnershipQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const AccountabilityPartnership = mongoose.model<AccountabilityPartnershipDocument, AccountabilityPartnershipModel>("AccountabilityPartnership", AccountabilityPartnershipSchema);
 * ```
 */
export type AccountabilityPartnershipDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  AccountabilityPartnershipQueries
> &
  AccountabilityPartnershipMethods & {
    user1: UserDocument["_id"] | UserDocument
    user2: UserDocument["_id"] | UserDocument
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of ActivityDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `ActivityDocument.toObject()`. To avoid conflicts with model names, use the type alias `ActivityObject`.
 * ```
 * const activityObject = activity.toObject();
 * ```
 */
export type Activity = {
  user: User["_id"] | User
  type:
    | "goal"
    | "reminder"
    | "post"
    | "message"
    | "login"
    | "logout"
    | "signup"
    | "friend_request"
    | "friend_accept"
    | "comment"
    | "reaction"
    | "achievement"
  description: string
  metadata?: any
  participants: (User["_id"] | User)[]
  isDeleted?: boolean
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of ActivityDocument (type alias of `Activity`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Activity } from "../models"
 * import { ActivityObject } from "../interfaces/mongoose.gen.ts"
 *
 * const activityObject: ActivityObject = activity.toObject();
 * ```
 */
export type ActivityObject = Activity

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type ActivityQuery = mongoose.Query<
  any,
  ActivityDocument,
  ActivityQueries
> &
  ActivityQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `ActivitySchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type ActivityQueries = {}

export type ActivityMethods = {
  addParticipant: (
    this: ActivityDocument,
    userId: mongoose.Types.ObjectId
  ) => Promise<void>
  markDeleted: (this: ActivityDocument) => Promise<void>
}

export type ActivityStatics = {
  getRecentForUser: (
    this: ActivityModel,
    userId: mongoose.Types.ObjectId,
    limit: number
  ) => any
  getByType: (this: ActivityModel, type: any) => any
  softDeleteByUser: (
    this: ActivityModel,
    userId: mongoose.Types.ObjectId
  ) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Activity = mongoose.model<ActivityDocument, ActivityModel>("Activity", ActivitySchema);
 * ```
 */
export type ActivityModel = mongoose.Model<ActivityDocument, ActivityQueries> &
  ActivityStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Activity schema instances:
 * ```
 * const ActivitySchema: ActivitySchema = new mongoose.Schema({ ... })
 * ```
 */
export type ActivitySchema = mongoose.Schema<
  ActivityDocument,
  ActivityModel,
  ActivityMethods,
  ActivityQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Activity = mongoose.model<ActivityDocument, ActivityModel>("Activity", ActivitySchema);
 * ```
 */
export type ActivityDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  ActivityQueries
> &
  ActivityMethods & {
    user: UserDocument["_id"] | UserDocument
    type:
      | "goal"
      | "reminder"
      | "post"
      | "message"
      | "login"
      | "logout"
      | "signup"
      | "friend_request"
      | "friend_accept"
      | "comment"
      | "reaction"
      | "achievement"
    description: string
    metadata?: any
    participants: mongoose.Types.Array<UserDocument["_id"] | UserDocument>
    isDeleted?: boolean
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of AnonymousMilitaryMessageDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `AnonymousMilitaryMessageDocument.toObject()`. To avoid conflicts with model names, use the type alias `AnonymousMilitaryMessageObject`.
 * ```
 * const anonymousmilitarymessageObject = anonymousmilitarymessage.toObject();
 * ```
 */
export type AnonymousMilitaryMessage = {
  room: "veterans-support" | "active-duty" | "family-members"
  anonymousSessionId: string
  displayName: string
  message: string
  isFlagged?: boolean
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of AnonymousMilitaryMessageDocument (type alias of `AnonymousMilitaryMessage`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { AnonymousMilitaryMessage } from "../models"
 * import { AnonymousMilitaryMessageObject } from "../interfaces/mongoose.gen.ts"
 *
 * const anonymousmilitarymessageObject: AnonymousMilitaryMessageObject = anonymousmilitarymessage.toObject();
 * ```
 */
export type AnonymousMilitaryMessageObject = AnonymousMilitaryMessage

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type AnonymousMilitaryMessageQuery = mongoose.Query<
  any,
  AnonymousMilitaryMessageDocument,
  AnonymousMilitaryMessageQueries
> &
  AnonymousMilitaryMessageQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `AnonymousMilitaryMessageSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type AnonymousMilitaryMessageQueries = {}

export type AnonymousMilitaryMessageMethods = {}

export type AnonymousMilitaryMessageStatics = {}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const AnonymousMilitaryMessage = mongoose.model<AnonymousMilitaryMessageDocument, AnonymousMilitaryMessageModel>("AnonymousMilitaryMessage", AnonymousMilitaryMessageSchema);
 * ```
 */
export type AnonymousMilitaryMessageModel = mongoose.Model<
  AnonymousMilitaryMessageDocument,
  AnonymousMilitaryMessageQueries
> &
  AnonymousMilitaryMessageStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new AnonymousMilitaryMessage schema instances:
 * ```
 * const AnonymousMilitaryMessageSchema: AnonymousMilitaryMessageSchema = new mongoose.Schema({ ... })
 * ```
 */
export type AnonymousMilitaryMessageSchema = mongoose.Schema<
  AnonymousMilitaryMessageDocument,
  AnonymousMilitaryMessageModel,
  AnonymousMilitaryMessageMethods,
  AnonymousMilitaryMessageQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const AnonymousMilitaryMessage = mongoose.model<AnonymousMilitaryMessageDocument, AnonymousMilitaryMessageModel>("AnonymousMilitaryMessage", AnonymousMilitaryMessageSchema);
 * ```
 */
export type AnonymousMilitaryMessageDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  AnonymousMilitaryMessageQueries
> &
  AnonymousMilitaryMessageMethods & {
    room: "veterans-support" | "active-duty" | "family-members"
    anonymousSessionId: string
    displayName: string
    message: string
    isFlagged?: boolean
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of AnonymousSessionDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `AnonymousSessionDocument.toObject()`. To avoid conflicts with model names, use the type alias `AnonymousSessionObject`.
 * ```
 * const anonymoussessionObject = anonymoussession.toObject();
 * ```
 */
export type AnonymousSession = {
  sessionId: string
  displayName: string
  room: "veterans-support" | "active-duty" | "family-members"
  lastActive?: Date
  joinedAt?: Date
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of AnonymousSessionDocument (type alias of `AnonymousSession`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { AnonymousSession } from "../models"
 * import { AnonymousSessionObject } from "../interfaces/mongoose.gen.ts"
 *
 * const anonymoussessionObject: AnonymousSessionObject = anonymoussession.toObject();
 * ```
 */
export type AnonymousSessionObject = AnonymousSession

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type AnonymousSessionQuery = mongoose.Query<
  any,
  AnonymousSessionDocument,
  AnonymousSessionQueries
> &
  AnonymousSessionQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `AnonymousSessionSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type AnonymousSessionQueries = {}

export type AnonymousSessionMethods = {}

export type AnonymousSessionStatics = {
  getActiveSessionsInRoom: (
    this: AnonymousSessionModel,
    room: string
  ) => Promise<any>
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const AnonymousSession = mongoose.model<AnonymousSessionDocument, AnonymousSessionModel>("AnonymousSession", AnonymousSessionSchema);
 * ```
 */
export type AnonymousSessionModel = mongoose.Model<
  AnonymousSessionDocument,
  AnonymousSessionQueries
> &
  AnonymousSessionStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new AnonymousSession schema instances:
 * ```
 * const AnonymousSessionSchema: AnonymousSessionSchema = new mongoose.Schema({ ... })
 * ```
 */
export type AnonymousSessionSchema = mongoose.Schema<
  AnonymousSessionDocument,
  AnonymousSessionModel,
  AnonymousSessionMethods,
  AnonymousSessionQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const AnonymousSession = mongoose.model<AnonymousSessionDocument, AnonymousSessionModel>("AnonymousSession", AnonymousSessionSchema);
 * ```
 */
export type AnonymousSessionDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  AnonymousSessionQueries
> &
  AnonymousSessionMethods & {
    sessionId: string
    displayName: string
    room: "veterans-support" | "active-duty" | "family-members"
    lastActive?: Date
    joinedAt?: Date
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of AnonymousMoodCheckInDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `AnonymousMoodCheckInDocument.toObject()`. To avoid conflicts with model names, use the type alias `AnonymousMoodCheckInObject`.
 * ```
 * const anonymousmoodcheckinObject = anonymousmoodcheckin.toObject();
 * ```
 */
export type AnonymousMoodCheckIn = {
  sessionId: string
  mood: number
  note?: string | null
  ipAddress?: string | null
  userAgent?: string | null
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of AnonymousMoodCheckInDocument (type alias of `AnonymousMoodCheckIn`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { AnonymousMoodCheckIn } from "../models"
 * import { AnonymousMoodCheckInObject } from "../interfaces/mongoose.gen.ts"
 *
 * const anonymousmoodcheckinObject: AnonymousMoodCheckInObject = anonymousmoodcheckin.toObject();
 * ```
 */
export type AnonymousMoodCheckInObject = AnonymousMoodCheckIn

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type AnonymousMoodCheckInQuery = mongoose.Query<
  any,
  AnonymousMoodCheckInDocument,
  AnonymousMoodCheckInQueries
> &
  AnonymousMoodCheckInQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `AnonymousMoodCheckInSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type AnonymousMoodCheckInQueries = {}

export type AnonymousMoodCheckInMethods = {}

export type AnonymousMoodCheckInStatics = {
  getTodaysMoodDistribution: (
    this: AnonymousMoodCheckInModel
  ) => Promise<{
    date: string
    averageMood: number
    totalCheckIns: any
    moodDistribution: {
      mood1: any
      mood2: any
      mood3: any
      mood4: any
      mood5: any
    }
  }>
  getMoodTrends: (
    this: AnonymousMoodCheckInModel,
    days?: number
  ) => Promise<any>
  hasSubmittedToday: (
    this: AnonymousMoodCheckInModel,
    sessionId: string
  ) => Promise<boolean>
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const AnonymousMoodCheckIn = mongoose.model<AnonymousMoodCheckInDocument, AnonymousMoodCheckInModel>("AnonymousMoodCheckIn", AnonymousMoodCheckInSchema);
 * ```
 */
export type AnonymousMoodCheckInModel = mongoose.Model<
  AnonymousMoodCheckInDocument,
  AnonymousMoodCheckInQueries
> &
  AnonymousMoodCheckInStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new AnonymousMoodCheckIn schema instances:
 * ```
 * const AnonymousMoodCheckInSchema: AnonymousMoodCheckInSchema = new mongoose.Schema({ ... })
 * ```
 */
export type AnonymousMoodCheckInSchema = mongoose.Schema<
  AnonymousMoodCheckInDocument,
  AnonymousMoodCheckInModel,
  AnonymousMoodCheckInMethods,
  AnonymousMoodCheckInQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const AnonymousMoodCheckIn = mongoose.model<AnonymousMoodCheckInDocument, AnonymousMoodCheckInModel>("AnonymousMoodCheckIn", AnonymousMoodCheckInSchema);
 * ```
 */
export type AnonymousMoodCheckInDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  AnonymousMoodCheckInQueries
> &
  AnonymousMoodCheckInMethods & {
    sessionId: string
    mood: number
    note?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of BadgeDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `BadgeDocument.toObject()`. To avoid conflicts with model names, use the type alias `BadgeObject`.
 * ```
 * const badgeObject = badge.toObject();
 * ```
 */
export type Badge = {
  user: User["_id"] | User
  badgeType: BadgeType["_id"] | BadgeType
  level?: "Bronze" | "Silver" | "Gold"
  progress?: number
  dateAwarded?: Date
  isShowcased?: boolean
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of BadgeDocument (type alias of `Badge`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Badge } from "../models"
 * import { BadgeObject } from "../interfaces/mongoose.gen.ts"
 *
 * const badgeObject: BadgeObject = badge.toObject();
 * ```
 */
export type BadgeObject = Badge

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type BadgeQuery = mongoose.Query<any, BadgeDocument, BadgeQueries> &
  BadgeQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `BadgeSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type BadgeQueries = {}

export type BadgeMethods = {}

export type BadgeStatics = {}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Badge = mongoose.model<BadgeDocument, BadgeModel>("Badge", BadgeSchema);
 * ```
 */
export type BadgeModel = mongoose.Model<BadgeDocument, BadgeQueries> &
  BadgeStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Badge schema instances:
 * ```
 * const BadgeSchema: BadgeSchema = new mongoose.Schema({ ... })
 * ```
 */
export type BadgeSchema = mongoose.Schema<
  BadgeDocument,
  BadgeModel,
  BadgeMethods,
  BadgeQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Badge = mongoose.model<BadgeDocument, BadgeModel>("Badge", BadgeSchema);
 * ```
 */
export type BadgeDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  BadgeQueries
> &
  BadgeMethods & {
    user: UserDocument["_id"] | UserDocument
    badgeType: BadgeTypeDocument["_id"] | BadgeTypeDocument
    level?: "Bronze" | "Silver" | "Gold"
    progress?: number
    dateAwarded?: Date
    isShowcased?: boolean
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of BadgeTypeDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `BadgeTypeDocument.toObject()`. To avoid conflicts with model names, use the type alias `BadgeTypeObject`.
 * ```
 * const badgetypeObject = badgetype.toObject();
 * ```
 */
export type BadgeType = {
  name: string
  description?: string
  bronzePointsToAward?: number
  silverPointsToAward?: number
  goldPointsToAward?: number
  iconKey?: string
  conditionToMeet: "goal_completed" | "consistency_master" | "point_earner"
  bronzeAmountRequired?: number
  silverAmountRequired?: number
  goldAmountRequired?: number
  expiresAt?: Date
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
  isExpired: boolean
}

/**
 * Lean version of BadgeTypeDocument (type alias of `BadgeType`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { BadgeType } from "../models"
 * import { BadgeTypeObject } from "../interfaces/mongoose.gen.ts"
 *
 * const badgetypeObject: BadgeTypeObject = badgetype.toObject();
 * ```
 */
export type BadgeTypeObject = BadgeType

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type BadgeTypeQuery = mongoose.Query<
  any,
  BadgeTypeDocument,
  BadgeTypeQueries
> &
  BadgeTypeQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `BadgeTypeSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type BadgeTypeQueries = {}

export type BadgeTypeMethods = {
  getIconUrl: (this: BadgeTypeDocument) => Promise<string>
}

export type BadgeTypeStatics = {}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const BadgeType = mongoose.model<BadgeTypeDocument, BadgeTypeModel>("BadgeType", BadgeTypeSchema);
 * ```
 */
export type BadgeTypeModel = mongoose.Model<
  BadgeTypeDocument,
  BadgeTypeQueries
> &
  BadgeTypeStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new BadgeType schema instances:
 * ```
 * const BadgeTypeSchema: BadgeTypeSchema = new mongoose.Schema({ ... })
 * ```
 */
export type BadgeTypeSchema = mongoose.Schema<
  BadgeTypeDocument,
  BadgeTypeModel,
  BadgeTypeMethods,
  BadgeTypeQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const BadgeType = mongoose.model<BadgeTypeDocument, BadgeTypeModel>("BadgeType", BadgeTypeSchema);
 * ```
 */
export type BadgeTypeDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  BadgeTypeQueries
> &
  BadgeTypeMethods & {
    name: string
    description?: string
    bronzePointsToAward?: number
    silverPointsToAward?: number
    goldPointsToAward?: number
    iconKey?: string
    conditionToMeet: "goal_completed" | "consistency_master" | "point_earner"
    bronzeAmountRequired?: number
    silverAmountRequired?: number
    goldAmountRequired?: number
    expiresAt?: Date
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
    isExpired: boolean
  }

/**
 * Lean version of BookCommentDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `BookDocument.toObject()`.
 * ```
 * const bookObject = book.toObject();
 * ```
 */
export type BookComment = {
  user: User["_id"] | User
  text: string
  createdAt?: Date
  _id: mongoose.Types.ObjectId
}

/**
 * Lean version of BookDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `BookDocument.toObject()`. To avoid conflicts with model names, use the type alias `BookObject`.
 * ```
 * const bookObject = book.toObject();
 * ```
 */
export type Book = {
  title: string
  author: string
  category: string
  description: string
  coverImage?: string
  addedBy: User["_id"] | User
  likes: (User["_id"] | User)[]
  comments: BookComment[]
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
  likeCount: number
  commentCount: number
}

/**
 * Lean version of BookDocument (type alias of `Book`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Book } from "../models"
 * import { BookObject } from "../interfaces/mongoose.gen.ts"
 *
 * const bookObject: BookObject = book.toObject();
 * ```
 */
export type BookObject = Book

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type BookQuery = mongoose.Query<any, BookDocument, BookQueries> &
  BookQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `BookSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type BookQueries = {}

export type BookMethods = {
  addLike: (this: BookDocument, userId: mongoose.Types.ObjectId) => Promise<any>
  removeLike: (
    this: BookDocument,
    userId: mongoose.Types.ObjectId
  ) => Promise<any>
  addComment: (
    this: BookDocument,
    userId: mongoose.Types.ObjectId,
    text: string
  ) => Promise<any>
  removeComment: (
    this: BookDocument,
    commentId: mongoose.Types.ObjectId
  ) => Promise<boolean>
}

export type BookStatics = {
  findByCategory: (this: BookModel, category: string, limit?: number) => any
  findRecent: (this: BookModel, limit?: number) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Book = mongoose.model<BookDocument, BookModel>("Book", BookSchema);
 * ```
 */
export type BookModel = mongoose.Model<BookDocument, BookQueries> & BookStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Book schema instances:
 * ```
 * const BookSchema: BookSchema = new mongoose.Schema({ ... })
 * ```
 */
export type BookSchema = mongoose.Schema<
  BookDocument,
  BookModel,
  BookMethods,
  BookQueries
>

/**
 * Mongoose Subdocument type
 *
 * Type of `BookDocument["comments"]` element.
 */
export type BookCommentDocument =
  mongoose.Types.Subdocument<mongoose.Types.ObjectId> & {
    user: UserDocument["_id"] | UserDocument
    text: string
    createdAt?: Date
    _id: mongoose.Types.ObjectId
  }

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Book = mongoose.model<BookDocument, BookModel>("Book", BookSchema);
 * ```
 */
export type BookDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  BookQueries
> &
  BookMethods & {
    title: string
    author: string
    category: string
    description: string
    coverImage?: string
    addedBy: UserDocument["_id"] | UserDocument
    likes: mongoose.Types.Array<UserDocument["_id"] | UserDocument>
    comments: mongoose.Types.DocumentArray<BookCommentDocument>
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
    likeCount: number
    commentCount: number
  }

/**
 * Lean version of ChatUnreadMessageDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `ChatDocument.toObject()`.
 * ```
 * const chatObject = chat.toObject();
 * ```
 */
export type ChatUnreadMessage = {
  userId: User["_id"] | User
  count?: number
  _id: mongoose.Types.ObjectId
}

/**
 * Lean version of ChatDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `ChatDocument.toObject()`. To avoid conflicts with model names, use the type alias `ChatObject`.
 * ```
 * const chatObject = chat.toObject();
 * ```
 */
export type Chat = {
  participants: (User["_id"] | User)[]
  messages: (Message["_id"] | Message)[]
  lastMessage?: Message["_id"] | Message
  chatType: "private" | "group"
  groupId?: Group["_id"] | Group
  unreadMessages: ChatUnreadMessage[]
  typingUsers: (User["_id"] | User)[]
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
  participantCount: number
}

/**
 * Lean version of ChatDocument (type alias of `Chat`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Chat } from "../models"
 * import { ChatObject } from "../interfaces/mongoose.gen.ts"
 *
 * const chatObject: ChatObject = chat.toObject();
 * ```
 */
export type ChatObject = Chat

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type ChatQuery = mongoose.Query<any, ChatDocument, ChatQueries> &
  ChatQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `ChatSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type ChatQueries = {}

export type ChatMethods = {
  addMessage: (
    this: ChatDocument,
    messageId: mongoose.Types.ObjectId,
    userId: mongoose.Types.ObjectId
  ) => Promise<any>
  markRead: (
    this: ChatDocument,
    userId: mongoose.Types.ObjectId
  ) => Promise<any>
  addTypingUser: (
    this: ChatDocument,
    userId: mongoose.Types.ObjectId
  ) => Promise<any>
  removeTypingUser: (
    this: ChatDocument,
    userId: mongoose.Types.ObjectId
  ) => Promise<any>
}

export type ChatStatics = {
  getUserChats: (this: ChatModel, userId: mongoose.Types.ObjectId) => any
  getGroupChats: (this: ChatModel) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Chat = mongoose.model<ChatDocument, ChatModel>("Chat", ChatSchema);
 * ```
 */
export type ChatModel = mongoose.Model<ChatDocument, ChatQueries> & ChatStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Chat schema instances:
 * ```
 * const ChatSchema: ChatSchema = new mongoose.Schema({ ... })
 * ```
 */
export type ChatSchema = mongoose.Schema<
  ChatDocument,
  ChatModel,
  ChatMethods,
  ChatQueries
>

/**
 * Mongoose Subdocument type
 *
 * Type of `ChatDocument["unreadMessages"]` element.
 */
export type ChatUnreadMessageDocument =
  mongoose.Types.Subdocument<mongoose.Types.ObjectId> & {
    userId: UserDocument["_id"] | UserDocument
    count?: number
    _id: mongoose.Types.ObjectId
  }

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Chat = mongoose.model<ChatDocument, ChatModel>("Chat", ChatSchema);
 * ```
 */
export type ChatDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  ChatQueries
> &
  ChatMethods & {
    participants: mongoose.Types.Array<UserDocument["_id"] | UserDocument>
    messages: mongoose.Types.Array<MessageDocument["_id"] | MessageDocument>
    lastMessage?: MessageDocument["_id"] | MessageDocument
    chatType: "private" | "group"
    groupId?: GroupDocument["_id"] | GroupDocument
    unreadMessages: mongoose.Types.DocumentArray<ChatUnreadMessageDocument>
    typingUsers: mongoose.Types.Array<UserDocument["_id"] | UserDocument>
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
    participantCount: number
  }

/**
 * Lean version of CheckInDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `CheckInDocument.toObject()`. To avoid conflicts with model names, use the type alias `CheckInObject`.
 * ```
 * const checkinObject = checkin.toObject();
 * ```
 */
export type CheckIn = {
  user: User["_id"] | User
  createdAt?: Date
  _id: mongoose.Types.ObjectId
}

/**
 * Lean version of CheckInDocument (type alias of `CheckIn`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { CheckIn } from "../models"
 * import { CheckInObject } from "../interfaces/mongoose.gen.ts"
 *
 * const checkinObject: CheckInObject = checkin.toObject();
 * ```
 */
export type CheckInObject = CheckIn

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type CheckInQuery = mongoose.Query<
  any,
  CheckInDocument,
  CheckInQueries
> &
  CheckInQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `CheckInSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type CheckInQueries = {}

export type CheckInMethods = {}

export type CheckInStatics = {}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const CheckIn = mongoose.model<CheckInDocument, CheckInModel>("CheckIn", CheckInSchema);
 * ```
 */
export type CheckInModel = mongoose.Model<CheckInDocument, CheckInQueries> &
  CheckInStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new CheckIn schema instances:
 * ```
 * const CheckInSchema: CheckInSchema = new mongoose.Schema({ ... })
 * ```
 */
export type CheckInSchema = mongoose.Schema<
  CheckInDocument,
  CheckInModel,
  CheckInMethods,
  CheckInQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const CheckIn = mongoose.model<CheckInDocument, CheckInModel>("CheckIn", CheckInSchema);
 * ```
 */
export type CheckInDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  CheckInQueries
> &
  CheckInMethods & {
    user: UserDocument["_id"] | UserDocument
    createdAt?: Date
    _id: mongoose.Types.ObjectId
  }

/**
 * Lean version of CollaborationGoalDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `CollaborationGoalDocument.toObject()`. To avoid conflicts with model names, use the type alias `CollaborationGoalObject`.
 * ```
 * const collaborationgoalObject = collaborationgoal.toObject();
 * ```
 */
export type CollaborationGoal = {
  title: string
  description?: string
  status?: "not-started" | "in-progress" | "completed" | "archived"
  progress?: number
  completedAt?: Date
  milestones: (Milestone["_id"] | Milestone)[]
  visibility?: "public" | "private"
  createdBy: User["_id"] | User
  participants: (User["_id"] | User)[]
  target: number
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
  participantCount: any
  milestoneCount: any
}

/**
 * Lean version of CollaborationGoalDocument (type alias of `CollaborationGoal`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { CollaborationGoal } from "../models"
 * import { CollaborationGoalObject } from "../interfaces/mongoose.gen.ts"
 *
 * const collaborationgoalObject: CollaborationGoalObject = collaborationgoal.toObject();
 * ```
 */
export type CollaborationGoalObject = CollaborationGoal

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type CollaborationGoalQuery = mongoose.Query<
  any,
  CollaborationGoalDocument,
  CollaborationGoalQueries
> &
  CollaborationGoalQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `CollaborationGoalSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type CollaborationGoalQueries = {}

export type CollaborationGoalMethods = {
  updateProgress: (
    this: CollaborationGoalDocument,
    newProgress: number
  ) => Promise<any>
  addParticipant: (
    this: CollaborationGoalDocument,
    userId: mongoose.Types.ObjectId
  ) => Promise<any>
  completeMilestone: (
    this: CollaborationGoalDocument,
    index: number
  ) => Promise<any>
}

export type CollaborationGoalStatics = {
  fetchByVisibility: (
    this: CollaborationGoalModel,
    visibility: "public" | "private",
    limit?: number
  ) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const CollaborationGoal = mongoose.model<CollaborationGoalDocument, CollaborationGoalModel>("CollaborationGoal", CollaborationGoalSchema);
 * ```
 */
export type CollaborationGoalModel = mongoose.Model<
  CollaborationGoalDocument,
  CollaborationGoalQueries
> &
  CollaborationGoalStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new CollaborationGoal schema instances:
 * ```
 * const CollaborationGoalSchema: CollaborationGoalSchema = new mongoose.Schema({ ... })
 * ```
 */
export type CollaborationGoalSchema = mongoose.Schema<
  CollaborationGoalDocument,
  CollaborationGoalModel,
  CollaborationGoalMethods,
  CollaborationGoalQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const CollaborationGoal = mongoose.model<CollaborationGoalDocument, CollaborationGoalModel>("CollaborationGoal", CollaborationGoalSchema);
 * ```
 */
export type CollaborationGoalDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  CollaborationGoalQueries
> &
  CollaborationGoalMethods & {
    title: string
    description?: string
    status?: "not-started" | "in-progress" | "completed" | "archived"
    progress?: number
    completedAt?: Date
    milestones: mongoose.Types.Array<
      MilestoneDocument["_id"] | MilestoneDocument
    >
    visibility?: "public" | "private"
    createdBy: UserDocument["_id"] | UserDocument
    participants: mongoose.Types.Array<UserDocument["_id"] | UserDocument>
    target: number
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
    participantCount: any
    milestoneCount: any
  }

/**
 * Lean version of FaqDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `FaqDocument.toObject()`. To avoid conflicts with model names, use the type alias `FaqObject`.
 * ```
 * const faqObject = faq.toObject();
 * ```
 */
export type Faq = {
  question: string
  answer: string
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of FaqDocument (type alias of `Faq`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Faq } from "../models"
 * import { FaqObject } from "../interfaces/mongoose.gen.ts"
 *
 * const faqObject: FaqObject = faq.toObject();
 * ```
 */
export type FaqObject = Faq

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type FaqQuery = mongoose.Query<any, FaqDocument, FaqQueries> & FaqQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `FaqSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type FaqQueries = {}

export type FaqMethods = {}

export type FaqStatics = {}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Faq = mongoose.model<FaqDocument, FaqModel>("Faq", FaqSchema);
 * ```
 */
export type FaqModel = mongoose.Model<FaqDocument, FaqQueries> & FaqStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Faq schema instances:
 * ```
 * const FaqSchema: FaqSchema = new mongoose.Schema({ ... })
 * ```
 */
export type FaqSchema = mongoose.Schema<
  FaqDocument,
  FaqModel,
  FaqMethods,
  FaqQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Faq = mongoose.model<FaqDocument, FaqModel>("Faq", FaqSchema);
 * ```
 */
export type FaqDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  FaqQueries
> &
  FaqMethods & {
    question: string
    answer: string
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of FeedbackDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `FeedbackDocument.toObject()`. To avoid conflicts with model names, use the type alias `FeedbackObject`.
 * ```
 * const feedbackObject = feedback.toObject();
 * ```
 */
export type Feedback = {
  userId: User["_id"] | User
  message: string
  type?: "bug" | "feature-request" | "other"
  status?: "pending" | "reviewed" | "resolved"
  priority?: "low" | "medium" | "high"
  isAnonymous?: boolean
  relatedFeature?: string
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of FeedbackDocument (type alias of `Feedback`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Feedback } from "../models"
 * import { FeedbackObject } from "../interfaces/mongoose.gen.ts"
 *
 * const feedbackObject: FeedbackObject = feedback.toObject();
 * ```
 */
export type FeedbackObject = Feedback

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type FeedbackQuery = mongoose.Query<
  any,
  FeedbackDocument,
  FeedbackQueries
> &
  FeedbackQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `FeedbackSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type FeedbackQueries = {}

export type FeedbackMethods = {
  markAsReviewed: (this: FeedbackDocument, ...args: any[]) => any
}

export type FeedbackStatics = {
  getFeedbackByType: (this: FeedbackModel, ...args: any[]) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Feedback = mongoose.model<FeedbackDocument, FeedbackModel>("Feedback", FeedbackSchema);
 * ```
 */
export type FeedbackModel = mongoose.Model<FeedbackDocument, FeedbackQueries> &
  FeedbackStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Feedback schema instances:
 * ```
 * const FeedbackSchema: FeedbackSchema = new mongoose.Schema({ ... })
 * ```
 */
export type FeedbackSchema = mongoose.Schema<
  FeedbackDocument,
  FeedbackModel,
  FeedbackMethods,
  FeedbackQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Feedback = mongoose.model<FeedbackDocument, FeedbackModel>("Feedback", FeedbackSchema);
 * ```
 */
export type FeedbackDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  FeedbackQueries
> &
  FeedbackMethods & {
    userId: UserDocument["_id"] | UserDocument
    message: string
    type?: "bug" | "feature-request" | "other"
    status?: "pending" | "reviewed" | "resolved"
    priority?: "low" | "medium" | "high"
    isAnonymous?: boolean
    relatedFeature?: string
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of FriendRequestDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `FriendRequestDocument.toObject()`. To avoid conflicts with model names, use the type alias `FriendRequestObject`.
 * ```
 * const friendrequestObject = friendrequest.toObject();
 * ```
 */
export type FriendRequest = {
  sender: User["_id"] | User
  recipient: User["_id"] | User
  status?: "pending" | "accepted" | "declined"
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of FriendRequestDocument (type alias of `FriendRequest`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { FriendRequest } from "../models"
 * import { FriendRequestObject } from "../interfaces/mongoose.gen.ts"
 *
 * const friendrequestObject: FriendRequestObject = friendrequest.toObject();
 * ```
 */
export type FriendRequestObject = FriendRequest

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type FriendRequestQuery = mongoose.Query<
  any,
  FriendRequestDocument,
  FriendRequestQueries
> &
  FriendRequestQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `FriendRequestSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type FriendRequestQueries = {}

export type FriendRequestMethods = {}

export type FriendRequestStatics = {
  sendRequest: (
    this: FriendRequestModel,
    sender: mongoose.Types.ObjectId,
    recipient: mongoose.Types.ObjectId
  ) => Promise<any>
  respondRequest: (
    this: FriendRequestModel,
    requestId: mongoose.Types.ObjectId,
    status: FriendRequestStatus
  ) => Promise<any>
  getRequestsForUser: (
    this: FriendRequestModel,
    userId: mongoose.Types.ObjectId,
    status?: FriendRequestStatus
  ) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const FriendRequest = mongoose.model<FriendRequestDocument, FriendRequestModel>("FriendRequest", FriendRequestSchema);
 * ```
 */
export type FriendRequestModel = mongoose.Model<
  FriendRequestDocument,
  FriendRequestQueries
> &
  FriendRequestStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new FriendRequest schema instances:
 * ```
 * const FriendRequestSchema: FriendRequestSchema = new mongoose.Schema({ ... })
 * ```
 */
export type FriendRequestSchema = mongoose.Schema<
  FriendRequestDocument,
  FriendRequestModel,
  FriendRequestMethods,
  FriendRequestQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const FriendRequest = mongoose.model<FriendRequestDocument, FriendRequestModel>("FriendRequest", FriendRequestSchema);
 * ```
 */
export type FriendRequestDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  FriendRequestQueries
> &
  FriendRequestMethods & {
    sender: UserDocument["_id"] | UserDocument
    recipient: UserDocument["_id"] | UserDocument
    status?: "pending" | "accepted" | "declined"
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of GoalDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `GoalDocument.toObject()`. To avoid conflicts with model names, use the type alias `GoalObject`.
 * ```
 * const goalObject = goal.toObject();
 * ```
 */
export type Goal = {
  title: string
  description?: string
  status?: "not-started" | "in-progress" | "completed" | "archived"
  progress?: number
  completedAt?: Date
  milestones: (Milestone["_id"] | Milestone)[]
  visibility?: "public" | "private"
  user: User["_id"] | User
  category: string
  dueDate: Date
  tags: string[]
  priority?: "high" | "medium" | "low"
  reminders: (Reminder["_id"] | Reminder)[]
  isPinned?: boolean
  points?: number
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
  isActive: boolean
}

/**
 * Lean version of GoalDocument (type alias of `Goal`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Goal } from "../models"
 * import { GoalObject } from "../interfaces/mongoose.gen.ts"
 *
 * const goalObject: GoalObject = goal.toObject();
 * ```
 */
export type GoalObject = Goal

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type GoalQuery = mongoose.Query<any, GoalDocument, GoalQueries> &
  GoalQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `GoalSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type GoalQueries = {}

export type GoalMethods = {
  addReminder: (
    this: GoalDocument,
    message: string,
    remindAt: Date
  ) => Promise<any>
  markMilestoneComplete: (this: GoalDocument, index: number) => Promise<any>
}

export type GoalStatics = {
  findByUser: (
    this: GoalModel,
    userId: mongoose.Types.ObjectId,
    filter?: {}
  ) => any
  archiveCompleted: (this: GoalModel) => Promise<{ nDeleted: any }>
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Goal = mongoose.model<GoalDocument, GoalModel>("Goal", GoalSchema);
 * ```
 */
export type GoalModel = mongoose.Model<GoalDocument, GoalQueries> & GoalStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Goal schema instances:
 * ```
 * const GoalSchema: GoalSchema = new mongoose.Schema({ ... })
 * ```
 */
export type GoalSchema = mongoose.Schema<
  GoalDocument,
  GoalModel,
  GoalMethods,
  GoalQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Goal = mongoose.model<GoalDocument, GoalModel>("Goal", GoalSchema);
 * ```
 */
export type GoalDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  GoalQueries
> &
  GoalMethods & {
    title: string
    description?: string
    status?: "not-started" | "in-progress" | "completed" | "archived"
    progress?: number
    completedAt?: Date
    milestones: mongoose.Types.Array<
      MilestoneDocument["_id"] | MilestoneDocument
    >
    visibility?: "public" | "private"
    user: UserDocument["_id"] | UserDocument
    category: string
    dueDate: Date
    tags: mongoose.Types.Array<string>
    priority?: "high" | "medium" | "low"
    reminders: mongoose.Types.Array<ReminderDocument["_id"] | ReminderDocument>
    isPinned?: boolean
    points?: number
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
    isActive: boolean
  }

/**
 * Lean version of GroupDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `GroupDocument.toObject()`. To avoid conflicts with model names, use the type alias `GroupObject`.
 * ```
 * const groupObject = group.toObject();
 * ```
 */
export type Group = {
  name: string
  description?: string
  category: "fitness" | "study" | "career" | "lifestyle" | "creative" | "tech"
  members: (User["_id"] | User)[]
  createdBy: User["_id"] | User
  visibility?: "public" | "private"
  isActive?: boolean
  lastActivity?: Date
  avatar?: string | null
  tags: string[]
  isPinned?: boolean
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
  memberCount: number
  isPublic: boolean
}

/**
 * Lean version of GroupDocument (type alias of `Group`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Group } from "../models"
 * import { GroupObject } from "../interfaces/mongoose.gen.ts"
 *
 * const groupObject: GroupObject = group.toObject();
 * ```
 */
export type GroupObject = Group

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type GroupQuery = mongoose.Query<any, GroupDocument, GroupQueries> &
  GroupQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `GroupSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type GroupQueries = {}

export type GroupMethods = {
  addMember: (
    this: GroupDocument,
    userId: mongoose.Types.ObjectId
  ) => Promise<GroupDocument>
  removeMember: (
    this: GroupDocument,
    userId: mongoose.Types.ObjectId
  ) => Promise<GroupDocument>
}

export type GroupStatics = {
  findPublicGroups: (
    this: GroupModel
  ) => Promise<
    (mongoose.Document<
      unknown,
      import("/home/anaam/Programming/toptal/accountability-buddy/apps/backend/src/types/mongoose.gen").GroupQueries,
      GroupDocument
    > &
      mongoose.Document<
        mongoose.Types.ObjectId,
        import("/home/anaam/Programming/toptal/accountability-buddy/apps/backend/src/types/mongoose.gen").GroupQueries,
        any
      > &
      import("/home/anaam/Programming/toptal/accountability-buddy/apps/backend/src/types/mongoose.gen").GroupMethods & {
        name: string
        description?: string
        category:
          | "fitness"
          | "study"
          | "career"
          | "lifestyle"
          | "creative"
          | "tech"
        members: mongoose.Types.Array<
          | mongoose.Types.ObjectId
          | import("/home/anaam/Programming/toptal/accountability-buddy/apps/backend/src/types/mongoose.gen").UserDocument
        >
        createdBy:
          | mongoose.Types.ObjectId
          | import("/home/anaam/Programming/toptal/accountability-buddy/apps/backend/src/types/mongoose.gen").UserDocument
        visibility?: "public" | "private"
        isActive?: boolean
        lastActivity?: Date
        avatar?: string
        tags: mongoose.Types.Array<string>
        isPinned?: boolean
        _id: mongoose.Types.ObjectId
        createdAt?: Date
        updatedAt?: Date
        memberCount: number
        isPublic: boolean
      } & Required<{ _id: mongoose.Types.ObjectId }>)[]
  >
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Group = mongoose.model<GroupDocument, GroupModel>("Group", GroupSchema);
 * ```
 */
export type GroupModel = mongoose.Model<GroupDocument, GroupQueries> &
  GroupStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Group schema instances:
 * ```
 * const GroupSchema: GroupSchema = new mongoose.Schema({ ... })
 * ```
 */
export type GroupSchema = mongoose.Schema<
  GroupDocument,
  GroupModel,
  GroupMethods,
  GroupQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Group = mongoose.model<GroupDocument, GroupModel>("Group", GroupSchema);
 * ```
 */
export type GroupDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  GroupQueries
> &
  GroupMethods & {
    name: string
    description?: string
    category: "fitness" | "study" | "career" | "lifestyle" | "creative" | "tech"
    members: mongoose.Types.Array<UserDocument["_id"] | UserDocument>
    createdBy: UserDocument["_id"] | UserDocument
    visibility?: "public" | "private"
    isActive?: boolean
    lastActivity?: Date
    avatar?: string | null
    tags: mongoose.Types.Array<string>
    isPinned?: boolean
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
    memberCount: number
    isPublic: boolean
  }

/**
 * Lean version of GroupInvitationDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `GroupInvitationDocument.toObject()`. To avoid conflicts with model names, use the type alias `GroupInvitationObject`.
 * ```
 * const groupinvitationObject = groupinvitation.toObject();
 * ```
 */
export type GroupInvitation = {
  groupId: Group["_id"] | Group
  sender: User["_id"] | User
  recipient: User["_id"] | User
  status: "pending" | "accepted" | "rejected"
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of GroupInvitationDocument (type alias of `GroupInvitation`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { GroupInvitation } from "../models"
 * import { GroupInvitationObject } from "../interfaces/mongoose.gen.ts"
 *
 * const groupinvitationObject: GroupInvitationObject = groupinvitation.toObject();
 * ```
 */
export type GroupInvitationObject = GroupInvitation

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type GroupInvitationQuery = mongoose.Query<
  any,
  GroupInvitationDocument,
  GroupInvitationQueries
> &
  GroupInvitationQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `GroupInvitationSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type GroupInvitationQueries = {}

export type GroupInvitationMethods = {}

export type GroupInvitationStatics = {}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const GroupInvitation = mongoose.model<GroupInvitationDocument, GroupInvitationModel>("GroupInvitation", GroupInvitationSchema);
 * ```
 */
export type GroupInvitationModel = mongoose.Model<
  GroupInvitationDocument,
  GroupInvitationQueries
> &
  GroupInvitationStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new GroupInvitation schema instances:
 * ```
 * const GroupInvitationSchema: GroupInvitationSchema = new mongoose.Schema({ ... })
 * ```
 */
export type GroupInvitationSchema = mongoose.Schema<
  GroupInvitationDocument,
  GroupInvitationModel,
  GroupInvitationMethods,
  GroupInvitationQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const GroupInvitation = mongoose.model<GroupInvitationDocument, GroupInvitationModel>("GroupInvitation", GroupInvitationSchema);
 * ```
 */
export type GroupInvitationDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  GroupInvitationQueries
> &
  GroupInvitationMethods & {
    groupId: GroupDocument["_id"] | GroupDocument
    sender: UserDocument["_id"] | UserDocument
    recipient: UserDocument["_id"] | UserDocument
    status: "pending" | "accepted" | "rejected"
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of LevelDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `LevelDocument.toObject()`. To avoid conflicts with model names, use the type alias `LevelObject`.
 * ```
 * const levelObject = level.toObject();
 * ```
 */
export type Level = {
  user: User["_id"] | User
  points?: number
  level?: number
  nextLevelAt?: number
  rewards: (Reward["_id"] | Reward)[]
  lastActivity?: Date
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
  totalRewards: any
}

/**
 * Lean version of LevelDocument (type alias of `Level`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Level } from "../models"
 * import { LevelObject } from "../interfaces/mongoose.gen.ts"
 *
 * const levelObject: LevelObject = level.toObject();
 * ```
 */
export type LevelObject = Level

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type LevelQuery = mongoose.Query<any, LevelDocument, LevelQueries> &
  LevelQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `LevelSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type LevelQueries = {}

export type LevelMethods = {
  addPoints: (this: LevelDocument, amount: number) => Promise<any>
  addReward: (
    this: LevelDocument,
    rewardType: any,
    rewardValue: string
  ) => Promise<any>
}

export type LevelStatics = {
  getTopLevels: (this: LevelModel, limit: number) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Level = mongoose.model<LevelDocument, LevelModel>("Level", LevelSchema);
 * ```
 */
export type LevelModel = mongoose.Model<LevelDocument, LevelQueries> &
  LevelStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Level schema instances:
 * ```
 * const LevelSchema: LevelSchema = new mongoose.Schema({ ... })
 * ```
 */
export type LevelSchema = mongoose.Schema<
  LevelDocument,
  LevelModel,
  LevelMethods,
  LevelQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Level = mongoose.model<LevelDocument, LevelModel>("Level", LevelSchema);
 * ```
 */
export type LevelDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  LevelQueries
> &
  LevelMethods & {
    user: UserDocument["_id"] | UserDocument
    points?: number
    level?: number
    nextLevelAt?: number
    rewards: mongoose.Types.Array<RewardDocument["_id"] | RewardDocument>
    lastActivity?: Date
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
    totalRewards: any
  }

/**
 * Lean version of MessageReactionDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `MessageDocument.toObject()`.
 * ```
 * const messageObject = message.toObject();
 * ```
 */
export type MessageReaction = {
  userId: User["_id"] | User
  emoji: string
  reactedAt?: Date
}

/**
 * Lean version of MessageAttachmentDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `MessageDocument.toObject()`.
 * ```
 * const messageObject = message.toObject();
 * ```
 */
export type MessageAttachment = {
  url: string
  type: "image" | "video" | "file"
}

/**
 * Lean version of MessageDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `MessageDocument.toObject()`. To avoid conflicts with model names, use the type alias `MessageObject`.
 * ```
 * const messageObject = message.toObject();
 * ```
 */
export type Message = {
  chatId: Chat["_id"] | Chat
  senderId: User["_id"] | User
  receiverId?: User["_id"] | User
  text?: string
  messageType: "private" | "group"
  status?: "sent" | "delivered" | "seen" | "deleted" | "edited"
  reactions: MessageReaction[]
  attachments: MessageAttachment[]
  replyTo?: Message["_id"] | Message
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
  reactionCount: number
  attachmentCount: number
}

/**
 * Lean version of MessageDocument (type alias of `Message`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Message } from "../models"
 * import { MessageObject } from "../interfaces/mongoose.gen.ts"
 *
 * const messageObject: MessageObject = message.toObject();
 * ```
 */
export type MessageObject = Message

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type MessageQuery = mongoose.Query<
  any,
  MessageDocument,
  MessageQueries
> &
  MessageQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `MessageSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type MessageQueries = {}

export type MessageMethods = {
  addReaction: (
    this: MessageDocument,
    userId: mongoose.Types.ObjectId,
    emoji: string
  ) => Promise<any>
  removeReaction: (
    this: MessageDocument,
    userId: mongoose.Types.ObjectId
  ) => Promise<any>
  edit: (this: MessageDocument, newText: string) => Promise<any>
  softDelete: (this: MessageDocument) => Promise<any>
}

export type MessageStatics = {
  getByChat: (
    this: MessageModel,
    chatId: mongoose.Types.ObjectId,
    limit?: number
  ) => any
  getUserMessages: (
    this: MessageModel,
    userId: mongoose.Types.ObjectId,
    limit?: number
  ) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Message = mongoose.model<MessageDocument, MessageModel>("Message", MessageSchema);
 * ```
 */
export type MessageModel = mongoose.Model<MessageDocument, MessageQueries> &
  MessageStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Message schema instances:
 * ```
 * const MessageSchema: MessageSchema = new mongoose.Schema({ ... })
 * ```
 */
export type MessageSchema = mongoose.Schema<
  MessageDocument,
  MessageModel,
  MessageMethods,
  MessageQueries
>

/**
 * Mongoose Subdocument type
 *
 * Type of `MessageDocument["reactions"]` element.
 */
export type MessageReactionDocument = mongoose.Types.Subdocument<any> & {
  userId: UserDocument["_id"] | UserDocument
  emoji: string
  reactedAt?: Date
}

/**
 * Mongoose Subdocument type
 *
 * Type of `MessageDocument["attachments"]` element.
 */
export type MessageAttachmentDocument = mongoose.Types.Subdocument<any> & {
  url: string
  type: "image" | "video" | "file"
}

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Message = mongoose.model<MessageDocument, MessageModel>("Message", MessageSchema);
 * ```
 */
export type MessageDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  MessageQueries
> &
  MessageMethods & {
    chatId: ChatDocument["_id"] | ChatDocument
    senderId: UserDocument["_id"] | UserDocument
    receiverId?: UserDocument["_id"] | UserDocument
    text?: string
    messageType: "private" | "group"
    status?: "sent" | "delivered" | "seen" | "deleted" | "edited"
    reactions: mongoose.Types.DocumentArray<MessageReactionDocument>
    attachments: mongoose.Types.DocumentArray<MessageAttachmentDocument>
    replyTo?: MessageDocument["_id"] | MessageDocument
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
    reactionCount: number
    attachmentCount: number
  }

/**
 * Lean version of MilestoneDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `MilestoneDocument.toObject()`. To avoid conflicts with model names, use the type alias `MilestoneObject`.
 * ```
 * const milestoneObject = milestone.toObject();
 * ```
 */
export type Milestone = {
  title: string
  description: string
  dueDate: Date
  completed?: boolean
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of MilestoneDocument (type alias of `Milestone`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Milestone } from "../models"
 * import { MilestoneObject } from "../interfaces/mongoose.gen.ts"
 *
 * const milestoneObject: MilestoneObject = milestone.toObject();
 * ```
 */
export type MilestoneObject = Milestone

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type MilestoneQuery = mongoose.Query<
  any,
  MilestoneDocument,
  MilestoneQueries
> &
  MilestoneQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `MilestoneSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type MilestoneQueries = {}

export type MilestoneMethods = {
  isPastDue: (this: MilestoneDocument) => boolean
}

export type MilestoneStatics = {
  findUpcoming: (this: MilestoneModel, daysAhead?: number) => any
  findOverdue: (this: MilestoneModel) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Milestone = mongoose.model<MilestoneDocument, MilestoneModel>("Milestone", MilestoneSchema);
 * ```
 */
export type MilestoneModel = mongoose.Model<
  MilestoneDocument,
  MilestoneQueries
> &
  MilestoneStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Milestone schema instances:
 * ```
 * const MilestoneSchema: MilestoneSchema = new mongoose.Schema({ ... })
 * ```
 */
export type MilestoneSchema = mongoose.Schema<
  MilestoneDocument,
  MilestoneModel,
  MilestoneMethods,
  MilestoneQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Milestone = mongoose.model<MilestoneDocument, MilestoneModel>("Milestone", MilestoneSchema);
 * ```
 */
export type MilestoneDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  MilestoneQueries
> &
  MilestoneMethods & {
    title: string
    description: string
    dueDate: Date
    completed?: boolean
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of ExternalSupportResourceDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `ExternalSupportResourceDocument.toObject()`. To avoid conflicts with model names, use the type alias `ExternalSupportResourceObject`.
 * ```
 * const externalsupportresourceObject = externalsupportresource.toObject();
 * ```
 */
export type ExternalSupportResource = {
  title: string
  url: string
  description?: string
  category?: "hotline" | "website" | "forum" | "organization" | "other"
  isActive?: boolean
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
  domain: string
}

/**
 * Lean version of ExternalSupportResourceDocument (type alias of `ExternalSupportResource`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { ExternalSupportResource } from "../models"
 * import { ExternalSupportResourceObject } from "../interfaces/mongoose.gen.ts"
 *
 * const externalsupportresourceObject: ExternalSupportResourceObject = externalsupportresource.toObject();
 * ```
 */
export type ExternalSupportResourceObject = ExternalSupportResource

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type ExternalSupportResourceQuery = mongoose.Query<
  any,
  ExternalSupportResourceDocument,
  ExternalSupportResourceQueries
> &
  ExternalSupportResourceQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `ExternalSupportResourceSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type ExternalSupportResourceQueries = {}

export type ExternalSupportResourceMethods = {
  deactivate: (this: ExternalSupportResourceDocument) => Promise<any>
  activate: (this: ExternalSupportResourceDocument) => Promise<any>
}

export type ExternalSupportResourceStatics = {
  findByCategory: (
    this: ExternalSupportResourceModel,
    category: ResourceCategory
  ) => any
  searchByTitle: (this: ExternalSupportResourceModel, text: string) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const ExternalSupportResource = mongoose.model<ExternalSupportResourceDocument, ExternalSupportResourceModel>("ExternalSupportResource", ExternalSupportResourceSchema);
 * ```
 */
export type ExternalSupportResourceModel = mongoose.Model<
  ExternalSupportResourceDocument,
  ExternalSupportResourceQueries
> &
  ExternalSupportResourceStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new ExternalSupportResource schema instances:
 * ```
 * const ExternalSupportResourceSchema: ExternalSupportResourceSchema = new mongoose.Schema({ ... })
 * ```
 */
export type ExternalSupportResourceSchema = mongoose.Schema<
  ExternalSupportResourceDocument,
  ExternalSupportResourceModel,
  ExternalSupportResourceMethods,
  ExternalSupportResourceQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const ExternalSupportResource = mongoose.model<ExternalSupportResourceDocument, ExternalSupportResourceModel>("ExternalSupportResource", ExternalSupportResourceSchema);
 * ```
 */
export type ExternalSupportResourceDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  ExternalSupportResourceQueries
> &
  ExternalSupportResourceMethods & {
    title: string
    url: string
    description?: string
    category?: "hotline" | "website" | "forum" | "organization" | "other"
    isActive?: boolean
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
    domain: string
  }

/**
 * Lean version of NotificationDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `NotificationDocument.toObject()`. To avoid conflicts with model names, use the type alias `NotificationObject`.
 * ```
 * const notificationObject = notification.toObject();
 * ```
 */
export type Notification = {
  user: User["_id"] | User
  sender?: User["_id"] | User | null
  message: string
  type:
    | "friend_request"
    | "message"
    | "group_invite"
    | "blog_activity"
    | "goal_milestone"
    | "group_request_rejected"
    | "group_request_accepted"
    | "group_invite_accepted"
    | "group_invite_rejected"
  read?: boolean
  link?: string
  expiresAt?: Date
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
  isExpired: boolean
}

/**
 * Lean version of NotificationDocument (type alias of `Notification`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Notification } from "../models"
 * import { NotificationObject } from "../interfaces/mongoose.gen.ts"
 *
 * const notificationObject: NotificationObject = notification.toObject();
 * ```
 */
export type NotificationObject = Notification

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type NotificationQuery = mongoose.Query<
  any,
  NotificationDocument,
  NotificationQueries
> &
  NotificationQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `NotificationSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type NotificationQueries = {}

export type NotificationMethods = {
  markRead: (this: NotificationDocument, ...args: any[]) => any
  markUnread: (this: NotificationDocument, ...args: any[]) => any
}

export type NotificationStatics = {
  findByUser: (this: NotificationModel, ...args: any[]) => any
  markAllRead: (this: NotificationModel, ...args: any[]) => any
  createNotification: (this: NotificationModel, ...args: any[]) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Notification = mongoose.model<NotificationDocument, NotificationModel>("Notification", NotificationSchema);
 * ```
 */
export type NotificationModel = mongoose.Model<
  NotificationDocument,
  NotificationQueries
> &
  NotificationStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Notification schema instances:
 * ```
 * const NotificationSchema: NotificationSchema = new mongoose.Schema({ ... })
 * ```
 */
export type NotificationSchema = mongoose.Schema<
  NotificationDocument,
  NotificationModel,
  NotificationMethods,
  NotificationQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Notification = mongoose.model<NotificationDocument, NotificationModel>("Notification", NotificationSchema);
 * ```
 */
export type NotificationDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  NotificationQueries
> &
  NotificationMethods & {
    user: UserDocument["_id"] | UserDocument
    sender?: UserDocument["_id"] | UserDocument | null
    message: string
    type:
      | "friend_request"
      | "message"
      | "group_invite"
      | "blog_activity"
      | "goal_milestone"
      | "group_request_rejected"
      | "group_request_accepted"
      | "group_invite_accepted"
      | "group_invite_rejected"
    read?: boolean
    link?: string
    expiresAt?: Date
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
    isExpired: boolean
  }

/**
 * Lean version of ReminderDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `ReminderDocument.toObject()`. To avoid conflicts with model names, use the type alias `ReminderObject`.
 * ```
 * const reminderObject = reminder.toObject();
 * ```
 */
export type Reminder = {
  user: User["_id"] | User
  message: string
  goal?: Goal["_id"] | Goal
  remindAt: Date
  recurrence?: "none" | "daily" | "weekly" | "monthly"
  isActive?: boolean
  isSent?: boolean
  reminderType?: "email" | "sms" | "app"
  email?: string
  lastSent?: Date
  endRepeat?: Date
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
  isRecurring: boolean
}

/**
 * Lean version of ReminderDocument (type alias of `Reminder`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Reminder } from "../models"
 * import { ReminderObject } from "../interfaces/mongoose.gen.ts"
 *
 * const reminderObject: ReminderObject = reminder.toObject();
 * ```
 */
export type ReminderObject = Reminder

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type ReminderQuery = mongoose.Query<
  any,
  ReminderDocument,
  ReminderQueries
> &
  ReminderQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `ReminderSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type ReminderQueries = {}

export type ReminderMethods = {
  deactivate: (this: ReminderDocument) => Promise<any>
  markAsSent: (this: ReminderDocument) => Promise<any>
}

export type ReminderStatics = {
  getUpcomingRemindersForUser: (
    this: ReminderModel,
    userId: mongoose.Types.ObjectId
  ) => any
  getUpcomingRemindersInRange: (
    this: ReminderModel,
    start: Date,
    end: Date
  ) => any
  getUserReminders: (
    this: ReminderModel,
    userId: mongoose.Types.ObjectId,
    filters?: {}
  ) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Reminder = mongoose.model<ReminderDocument, ReminderModel>("Reminder", ReminderSchema);
 * ```
 */
export type ReminderModel = mongoose.Model<ReminderDocument, ReminderQueries> &
  ReminderStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Reminder schema instances:
 * ```
 * const ReminderSchema: ReminderSchema = new mongoose.Schema({ ... })
 * ```
 */
export type ReminderSchema = mongoose.Schema<
  ReminderDocument,
  ReminderModel,
  ReminderMethods,
  ReminderQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Reminder = mongoose.model<ReminderDocument, ReminderModel>("Reminder", ReminderSchema);
 * ```
 */
export type ReminderDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  ReminderQueries
> &
  ReminderMethods & {
    user: UserDocument["_id"] | UserDocument
    message: string
    goal?: GoalDocument["_id"] | GoalDocument
    remindAt: Date
    recurrence?: "none" | "daily" | "weekly" | "monthly"
    isActive?: boolean
    isSent?: boolean
    reminderType?: "email" | "sms" | "app"
    email?: string
    lastSent?: Date
    endRepeat?: Date
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
    isRecurring: boolean
  }

/**
 * Lean version of RewardDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `RewardDocument.toObject()`. To avoid conflicts with model names, use the type alias `RewardObject`.
 * ```
 * const rewardObject = reward.toObject();
 * ```
 */
export type Reward = {
  name: string
  description: string
  pointsRequired: number
  rewardType: "badge" | "discount" | "giftCard" | "recognition"
  imageUrl?: string
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of RewardDocument (type alias of `Reward`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Reward } from "../models"
 * import { RewardObject } from "../interfaces/mongoose.gen.ts"
 *
 * const rewardObject: RewardObject = reward.toObject();
 * ```
 */
export type RewardObject = Reward

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type RewardQuery = mongoose.Query<any, RewardDocument, RewardQueries> &
  RewardQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `RewardSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type RewardQueries = {}

export type RewardMethods = {}

export type RewardStatics = {
  getAvailableRewards: (this: RewardModel, maxPoints: number) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Reward = mongoose.model<RewardDocument, RewardModel>("Reward", RewardSchema);
 * ```
 */
export type RewardModel = mongoose.Model<RewardDocument, RewardQueries> &
  RewardStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Reward schema instances:
 * ```
 * const RewardSchema: RewardSchema = new mongoose.Schema({ ... })
 * ```
 */
export type RewardSchema = mongoose.Schema<
  RewardDocument,
  RewardModel,
  RewardMethods,
  RewardQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Reward = mongoose.model<RewardDocument, RewardModel>("Reward", RewardSchema);
 * ```
 */
export type RewardDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  RewardQueries
> &
  RewardMethods & {
    name: string
    description: string
    pointsRequired: number
    rewardType: "badge" | "discount" | "giftCard" | "recognition"
    imageUrl?: string
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of RoleDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `RoleDocument.toObject()`. To avoid conflicts with model names, use the type alias `RoleObject`.
 * ```
 * const roleObject = role.toObject();
 * ```
 */
export type Role = {
  roleName: string
  permissions: string[]
  description?: string
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of RoleDocument (type alias of `Role`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Role } from "../models"
 * import { RoleObject } from "../interfaces/mongoose.gen.ts"
 *
 * const roleObject: RoleObject = role.toObject();
 * ```
 */
export type RoleObject = Role

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type RoleQuery = mongoose.Query<any, RoleDocument, RoleQueries> &
  RoleQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `RoleSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type RoleQueries = {}

export type RoleMethods = {
  hasPermission: (this: RoleDocument, ...args: any[]) => any
  addPermission: (this: RoleDocument, ...args: any[]) => any
  removePermission: (this: RoleDocument, ...args: any[]) => any
}

export type RoleStatics = {
  findByName: (this: RoleModel, ...args: any[]) => any
  getRolesWithPermission: (this: RoleModel, ...args: any[]) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Role = mongoose.model<RoleDocument, RoleModel>("Role", RoleSchema);
 * ```
 */
export type RoleModel = mongoose.Model<RoleDocument, RoleQueries> & RoleStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Role schema instances:
 * ```
 * const RoleSchema: RoleSchema = new mongoose.Schema({ ... })
 * ```
 */
export type RoleSchema = mongoose.Schema<
  RoleDocument,
  RoleModel,
  RoleMethods,
  RoleQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Role = mongoose.model<RoleDocument, RoleModel>("Role", RoleSchema);
 * ```
 */
export type RoleDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  RoleQueries
> &
  RoleMethods & {
    roleName: string
    permissions: mongoose.Types.Array<string>
    description?: string
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of StreakDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `StreakDocument.toObject()`. To avoid conflicts with model names, use the type alias `StreakObject`.
 * ```
 * const streakObject = streak.toObject();
 * ```
 */
export type Streak = {
  user: User["_id"] | User
  streakCount?: number
  lastCheckIn?: Date | null
  longestStreak?: number
  checkInDates: Date[]
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of StreakDocument (type alias of `Streak`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Streak } from "../models"
 * import { StreakObject } from "../interfaces/mongoose.gen.ts"
 *
 * const streakObject: StreakObject = streak.toObject();
 * ```
 */
export type StreakObject = Streak

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type StreakQuery = mongoose.Query<any, StreakDocument, StreakQueries> &
  StreakQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `StreakSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type StreakQueries = {}

export type StreakMethods = {
  recordCheckIn: (this: StreakDocument) => Promise<StreakDocument>
  resetStreak: (this: StreakDocument) => Promise<StreakDocument>
}

export type StreakStatics = {}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Streak = mongoose.model<StreakDocument, StreakModel>("Streak", StreakSchema);
 * ```
 */
export type StreakModel = mongoose.Model<StreakDocument, StreakQueries> &
  StreakStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Streak schema instances:
 * ```
 * const StreakSchema: StreakSchema = new mongoose.Schema({ ... })
 * ```
 */
export type StreakSchema = mongoose.Schema<
  StreakDocument,
  StreakModel,
  StreakMethods,
  StreakQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Streak = mongoose.model<StreakDocument, StreakModel>("Streak", StreakSchema);
 * ```
 */
export type StreakDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  StreakQueries
> &
  StreakMethods & {
    user: UserDocument["_id"] | UserDocument
    streakCount?: number
    lastCheckIn?: Date | null
    longestStreak?: number
    checkInDates: mongoose.Types.Array<Date>
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of UserLocationCoordinateDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `UserDocument.toObject()`.
 * ```
 * const userObject = user.toObject();
 * ```
 */
export type UserLocationCoordinate = {
  latitude: number
  longitude: number
}

/**
 * Lean version of UserDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `UserDocument.toObject()`. To avoid conflicts with model names, use the type alias `UserObject`.
 * ```
 * const userObject = user.toObject();
 * ```
 */
export type User = {
  username: string
  email: string
  password: string
  bio?: string
  profileImage?: string
  coverImage?: string
  name?: string
  role?: "user" | "admin" | "moderator" | "military"
  isVerified?: boolean
  permissions: string[]
  isLocked?: boolean
  active?: boolean
  friends: (User["_id"] | User)[]
  followers: (User["_id"] | User)[]
  following: (User["_id"] | User)[]
  rewards: (Reward["_id"] | Reward)[]
  badges: (Badge["_id"] | Badge)[]
  location: {
    country?: string
    state?: string
    city?: string
    coordinates?: UserLocationCoordinate
  }
  stripeCustomerId?: string
  stripeSubscriptionId?: string
  subscription_status?: "trial" | "active" | "expired" | "canceled" | "past_due"
  subscriptionTier?: "free-trial" | "basic" | "pro" | "elite"
  trial_start_date?: Date
  trial_end_date?: Date
  subscriptionStartDate?: Date
  subscriptionEndDate?: Date
  next_billing_date?: Date
  billing_cycle?: "monthly" | "yearly"
  interests: string[]
  chatPreferences: {
    preferredGroups: (Chat["_id"] | Chat)[]
    directMessagesOnly?: boolean
  }
  activeStatus?: "online" | "offline"
  settings: {
    notifications: {
      email?: boolean
      sms?: boolean
    }
    privacy: {
      profileVisibility?: "public" | "friends" | "private"
    }
  }
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of UserDocument (type alias of `User`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { User } from "../models"
 * import { UserObject } from "../interfaces/mongoose.gen.ts"
 *
 * const userObject: UserObject = user.toObject();
 * ```
 */
export type UserObject = User

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type UserQuery = mongoose.Query<any, UserDocument, UserQueries> &
  UserQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `UserSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type UserQueries = {}

export type UserMethods = {
  hasFeatureAccess: (this: UserDocument, feature: string) => boolean
  isSubscriptionActive: (this: UserDocument) => boolean
  isInTrial: (this: UserDocument) => boolean
  getDaysUntilTrialEnd: (this: UserDocument) => number
  comparePassword: (
    this: UserDocument,
    candidatePassword: string
  ) => Promise<any>
  awardBadge: (
    this: UserDocument,
    badgeId: mongoose.Types.ObjectId
  ) => Promise<void>
  getGoalLimit: (this: UserDocument) => number
  getTimezone: (this: UserDocument) => Promise<any>
  setOnline: (this: UserDocument) => any
  setOffline: (this: UserDocument) => any
}

export type UserStatics = {}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const User = mongoose.model<UserDocument, UserModel>("User", UserSchema);
 * ```
 */
export type UserModel = mongoose.Model<UserDocument, UserQueries> & UserStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new User schema instances:
 * ```
 * const UserSchema: UserSchema = new mongoose.Schema({ ... })
 * ```
 */
export type UserSchema = mongoose.Schema<
  UserDocument,
  UserModel,
  UserMethods,
  UserQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const User = mongoose.model<UserDocument, UserModel>("User", UserSchema);
 * ```
 */
export type UserLocationCoordinateDocument = mongoose.Document<any> & {
  latitude: number
  longitude: number
}

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const User = mongoose.model<UserDocument, UserModel>("User", UserSchema);
 * ```
 */
export type UserDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  UserQueries
> &
  UserMethods & {
    username: string
    email: string
    password: string
    bio?: string
    profileImage?: string
    coverImage?: string
    name?: string
    role?: "user" | "admin" | "moderator" | "military"
    isVerified?: boolean
    permissions: mongoose.Types.Array<string>
    isLocked?: boolean
    active?: boolean
    friends: mongoose.Types.Array<UserDocument["_id"] | UserDocument>
    followers: mongoose.Types.Array<UserDocument["_id"] | UserDocument>
    following: mongoose.Types.Array<UserDocument["_id"] | UserDocument>
    rewards: mongoose.Types.Array<RewardDocument["_id"] | RewardDocument>
    badges: mongoose.Types.Array<BadgeDocument["_id"] | BadgeDocument>
    location: {
      country?: string
      state?: string
      city?: string
      coordinates?: UserLocationCoordinateDocument
    }
    stripeCustomerId?: string
    stripeSubscriptionId?: string
    subscription_status?:
      | "trial"
      | "active"
      | "expired"
      | "canceled"
      | "past_due"
    subscriptionTier?: "free-trial" | "basic" | "pro" | "elite"
    trial_start_date?: Date
    trial_end_date?: Date
    subscriptionStartDate?: Date
    subscriptionEndDate?: Date
    next_billing_date?: Date
    billing_cycle?: "monthly" | "yearly"
    interests: mongoose.Types.Array<string>
    chatPreferences: {
      preferredGroups: mongoose.Types.Array<ChatDocument["_id"] | ChatDocument>
      directMessagesOnly?: boolean
    }
    activeStatus?: "online" | "offline"
    settings: {
      notifications: {
        email?: boolean
        sms?: boolean
      }
      privacy: {
        profileVisibility?: "public" | "friends" | "private"
      }
    }
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of VerificationTokenDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `VerificationTokenDocument.toObject()`. To avoid conflicts with model names, use the type alias `VerificationTokenObject`.
 * ```
 * const verificationtokenObject = verificationtoken.toObject();
 * ```
 */
export type VerificationToken = {
  user: User["_id"] | User
  token: string
  expiresAt: Date
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of VerificationTokenDocument (type alias of `VerificationToken`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { VerificationToken } from "../models"
 * import { VerificationTokenObject } from "../interfaces/mongoose.gen.ts"
 *
 * const verificationtokenObject: VerificationTokenObject = verificationtoken.toObject();
 * ```
 */
export type VerificationTokenObject = VerificationToken

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type VerificationTokenQuery = mongoose.Query<
  any,
  VerificationTokenDocument,
  VerificationTokenQueries
> &
  VerificationTokenQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `VerificationTokenSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type VerificationTokenQueries = {}

export type VerificationTokenMethods = {
  isExpired: (this: VerificationTokenDocument, ...args: any[]) => any
}

export type VerificationTokenStatics = {
  generate: (
    this: VerificationTokenModel,
    userId: mongoose.Types.ObjectId,
    expiresInSeconds?: number
  ) => Promise<VerificationTokenDocument>
  findValid: (
    this: VerificationTokenModel,
    token: string
  ) => Promise<VerificationTokenDocument | null>
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const VerificationToken = mongoose.model<VerificationTokenDocument, VerificationTokenModel>("VerificationToken", VerificationTokenSchema);
 * ```
 */
export type VerificationTokenModel = mongoose.Model<
  VerificationTokenDocument,
  VerificationTokenQueries
> &
  VerificationTokenStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new VerificationToken schema instances:
 * ```
 * const VerificationTokenSchema: VerificationTokenSchema = new mongoose.Schema({ ... })
 * ```
 */
export type VerificationTokenSchema = mongoose.Schema<
  VerificationTokenDocument,
  VerificationTokenModel,
  VerificationTokenMethods,
  VerificationTokenQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const VerificationToken = mongoose.model<VerificationTokenDocument, VerificationTokenModel>("VerificationToken", VerificationTokenSchema);
 * ```
 */
export type VerificationTokenDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  VerificationTokenQueries
> &
  VerificationTokenMethods & {
    user: UserDocument["_id"] | UserDocument
    token: string
    expiresAt: Date
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Check if a property on a document is populated:
 * ```
 * import { IsPopulated } from "../interfaces/mongoose.gen.ts"
 *
 * if (IsPopulated<UserDocument["bestFriend"]>) { ... }
 * ```
 */
export function IsPopulated<T>(doc: T | mongoose.Types.ObjectId): doc is T {
  return doc instanceof mongoose.Document
}

/**
 * Helper type used by `PopulatedDocument`. Returns the parent property of a string
 * representing a nested property (i.e. `friend.user` -> `friend`)
 */
type ParentProperty<T> = T extends `${infer P}.${string}` ? P : never

/**
 * Helper type used by `PopulatedDocument`. Returns the child property of a string
 * representing a nested property (i.e. `friend.user` -> `user`).
 */
type ChildProperty<T> = T extends `${string}.${infer C}` ? C : never

/**
 * Helper type used by `PopulatedDocument`. Removes the `ObjectId` from the general union type generated
 * for ref documents (i.e. `mongoose.Types.ObjectId | UserDocument` -> `UserDocument`)
 */
type PopulatedProperty<Root, T extends keyof Root> = Omit<Root, T> & {
  [ref in T]: Root[T] extends mongoose.Types.Array<infer U>
    ? mongoose.Types.Array<Exclude<U, mongoose.Types.ObjectId>>
    : Exclude<Root[T], mongoose.Types.ObjectId>
}

/**
 * Populate properties on a document type:
 * ```
 * import { PopulatedDocument } from "../interfaces/mongoose.gen.ts"
 *
 * function example(user: PopulatedDocument<UserDocument, "bestFriend">) {
 *   console.log(user.bestFriend._id) // typescript knows this is populated
 * }
 * ```
 */
export type PopulatedDocument<DocType, T> = T extends keyof DocType
  ? PopulatedProperty<DocType, T>
  : ParentProperty<T> extends keyof DocType
  ? Omit<DocType, ParentProperty<T>> & {
      [ref in ParentProperty<T>]: DocType[ParentProperty<T>] extends mongoose.Types.Array<
        infer U
      >
        ? mongoose.Types.Array<
            ChildProperty<T> extends keyof U
              ? PopulatedProperty<U, ChildProperty<T>>
              : PopulatedDocument<U, ChildProperty<T>>
          >
        : ChildProperty<T> extends keyof DocType[ParentProperty<T>]
        ? PopulatedProperty<DocType[ParentProperty<T>], ChildProperty<T>>
        : PopulatedDocument<DocType[ParentProperty<T>], ChildProperty<T>>
    }
  : DocType

/**
 * Helper types used by the populate overloads
 */
type Unarray<T> = T extends Array<infer U> ? U : T
type Modify<T, R> = Omit<T, keyof R> & R

/**
 * Augment mongoose with Query.populate overloads
 */
declare module "mongoose" {
  interface Query<ResultType, DocType, THelpers = {}> {
    populate<T extends string>(
      path: T,
      select?: string | any,
      model?: string | Model<any, THelpers>,
      match?: any
    ): Query<
      ResultType extends Array<DocType>
        ? Array<PopulatedDocument<Unarray<ResultType>, T>>
        : ResultType extends DocType
        ? PopulatedDocument<Unarray<ResultType>, T>
        : ResultType,
      DocType,
      THelpers
    > &
      THelpers

    populate<T extends string>(
      options: Modify<PopulateOptions, { path: T }> | Array<PopulateOptions>
    ): Query<
      ResultType extends Array<DocType>
        ? Array<PopulatedDocument<Unarray<ResultType>, T>>
        : ResultType extends DocType
        ? PopulatedDocument<Unarray<ResultType>, T>
        : ResultType,
      DocType,
      THelpers
    > &
      THelpers
  }
}
