/* tslint:disable */
/* eslint-disable */

// ######################################## THIS FILE WAS GENERATED BY MONGOOSE-TSGEN ######################################## //

// NOTE: ANY CHANGES MADE WILL BE OVERWRITTEN ON SUBSEQUENT EXECUTIONS OF MONGOOSE-TSGEN.

import mongoose from "mongoose"

/**
 * Lean version of AccountabilityPartnershipDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `AccountabilityPartnershipDocument.toObject()`. To avoid conflicts with model names, use the type alias `AccountabilityPartnershipObject`.
 * ```
 * const accountabilitypartnershipObject = accountabilitypartnership.toObject();
 * ```
 */
export type AccountabilityPartnership = {
  user1: User["_id"] | User
  user2: User["_id"] | User
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of AccountabilityPartnershipDocument (type alias of `AccountabilityPartnership`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { AccountabilityPartnership } from "../models"
 * import { AccountabilityPartnershipObject } from "../interfaces/mongoose.gen.ts"
 *
 * const accountabilitypartnershipObject: AccountabilityPartnershipObject = accountabilitypartnership.toObject();
 * ```
 */
export type AccountabilityPartnershipObject = AccountabilityPartnership

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type AccountabilityPartnershipQuery = mongoose.Query<
  any,
  AccountabilityPartnershipDocument,
  AccountabilityPartnershipQueries
> &
  AccountabilityPartnershipQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `AccountabilityPartnershipSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type AccountabilityPartnershipQueries = {}

export type AccountabilityPartnershipMethods = {}

export type AccountabilityPartnershipStatics = {
  findBetweenUsers: (
    this: AccountabilityPartnershipModel,
    u1: string,
    u2: string
  ) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const AccountabilityPartnership = mongoose.model<AccountabilityPartnershipDocument, AccountabilityPartnershipModel>("AccountabilityPartnership", AccountabilityPartnershipSchema);
 * ```
 */
export type AccountabilityPartnershipModel = mongoose.Model<
  AccountabilityPartnershipDocument,
  AccountabilityPartnershipQueries
> &
  AccountabilityPartnershipStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new AccountabilityPartnership schema instances:
 * ```
 * const AccountabilityPartnershipSchema: AccountabilityPartnershipSchema = new mongoose.Schema({ ... })
 * ```
 */
export type AccountabilityPartnershipSchema = mongoose.Schema<
  AccountabilityPartnershipDocument,
  AccountabilityPartnershipModel,
  AccountabilityPartnershipMethods,
  AccountabilityPartnershipQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const AccountabilityPartnership = mongoose.model<AccountabilityPartnershipDocument, AccountabilityPartnershipModel>("AccountabilityPartnership", AccountabilityPartnershipSchema);
 * ```
 */
export type AccountabilityPartnershipDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  AccountabilityPartnershipQueries
> &
  AccountabilityPartnershipMethods & {
    user1: UserDocument["_id"] | UserDocument
    user2: UserDocument["_id"] | UserDocument
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of AchievementDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `AchievementDocument.toObject()`. To avoid conflicts with model names, use the type alias `AchievementObject`.
 * ```
 * const achievementObject = achievement.toObject();
 * ```
 */
export type Achievement = {
  name: string
  description: string
  requirements: number
  badgeUrl?: string
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of AchievementDocument (type alias of `Achievement`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Achievement } from "../models"
 * import { AchievementObject } from "../interfaces/mongoose.gen.ts"
 *
 * const achievementObject: AchievementObject = achievement.toObject();
 * ```
 */
export type AchievementObject = Achievement

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type AchievementQuery = mongoose.Query<
  any,
  AchievementDocument,
  AchievementQueries
> &
  AchievementQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `AchievementSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type AchievementQueries = {}

export type AchievementMethods = {
  isUnlocked: (this: AchievementDocument, ...args: any[]) => any
}

export type AchievementStatics = {
  findByRequirement: (this: AchievementModel, ...args: any[]) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Achievement = mongoose.model<AchievementDocument, AchievementModel>("Achievement", AchievementSchema);
 * ```
 */
export type AchievementModel = mongoose.Model<
  AchievementDocument,
  AchievementQueries
> &
  AchievementStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Achievement schema instances:
 * ```
 * const AchievementSchema: AchievementSchema = new mongoose.Schema({ ... })
 * ```
 */
export type AchievementSchema = mongoose.Schema<
  AchievementDocument,
  AchievementModel,
  AchievementMethods,
  AchievementQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Achievement = mongoose.model<AchievementDocument, AchievementModel>("Achievement", AchievementSchema);
 * ```
 */
export type AchievementDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  AchievementQueries
> &
  AchievementMethods & {
    name: string
    description: string
    requirements: number
    badgeUrl?: string
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of ActivityDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `ActivityDocument.toObject()`. To avoid conflicts with model names, use the type alias `ActivityObject`.
 * ```
 * const activityObject = activity.toObject();
 * ```
 */
export type Activity = {
  user: User["_id"] | User
  type:
    | "goal"
    | "reminder"
    | "post"
    | "message"
    | "login"
    | "logout"
    | "signup"
    | "friend_request"
    | "friend_accept"
    | "comment"
    | "reaction"
    | "achievement"
  description: string
  metadata?: any
  participants: (User["_id"] | User)[]
  isDeleted?: boolean
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of ActivityDocument (type alias of `Activity`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Activity } from "../models"
 * import { ActivityObject } from "../interfaces/mongoose.gen.ts"
 *
 * const activityObject: ActivityObject = activity.toObject();
 * ```
 */
export type ActivityObject = Activity

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type ActivityQuery = mongoose.Query<
  any,
  ActivityDocument,
  ActivityQueries
> &
  ActivityQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `ActivitySchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type ActivityQueries = {}

export type ActivityMethods = {
  addParticipant: (
    this: ActivityDocument,
    userId: mongoose.Types.ObjectId
  ) => Promise<void>
  markDeleted: (this: ActivityDocument) => Promise<void>
}

export type ActivityStatics = {
  getRecentForUser: (
    this: ActivityModel,
    userId: mongoose.Types.ObjectId,
    limit: number
  ) => any
  getByType: (this: ActivityModel, type: any) => any
  softDeleteByUser: (
    this: ActivityModel,
    userId: mongoose.Types.ObjectId
  ) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Activity = mongoose.model<ActivityDocument, ActivityModel>("Activity", ActivitySchema);
 * ```
 */
export type ActivityModel = mongoose.Model<ActivityDocument, ActivityQueries> &
  ActivityStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Activity schema instances:
 * ```
 * const ActivitySchema: ActivitySchema = new mongoose.Schema({ ... })
 * ```
 */
export type ActivitySchema = mongoose.Schema<
  ActivityDocument,
  ActivityModel,
  ActivityMethods,
  ActivityQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Activity = mongoose.model<ActivityDocument, ActivityModel>("Activity", ActivitySchema);
 * ```
 */
export type ActivityDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  ActivityQueries
> &
  ActivityMethods & {
    user: UserDocument["_id"] | UserDocument
    type:
      | "goal"
      | "reminder"
      | "post"
      | "message"
      | "login"
      | "logout"
      | "signup"
      | "friend_request"
      | "friend_accept"
      | "comment"
      | "reaction"
      | "achievement"
    description: string
    metadata?: any
    participants: mongoose.Types.Array<UserDocument["_id"] | UserDocument>
    isDeleted?: boolean
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of AdminActionLogDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `AdminActionLogDocument.toObject()`. To avoid conflicts with model names, use the type alias `AdminActionLogObject`.
 * ```
 * const adminactionlogObject = adminactionlog.toObject();
 * ```
 */
export type AdminActionLog = {
  admin: User["_id"] | User
  action:
    | "create_user"
    | "delete_user"
    | "update_user_role"
    | "suspend_user"
    | "create_goal"
    | "delete_goal"
    | "modify_subscription"
    | "view_reports"
    | "other"
  description?: string
  target?: User["_id"] | User | null
  details?: Map<string, string>
  ipAddress?: string
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
  actionType: string
}

/**
 * Lean version of AdminActionLogDocument (type alias of `AdminActionLog`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { AdminActionLog } from "../models"
 * import { AdminActionLogObject } from "../interfaces/mongoose.gen.ts"
 *
 * const adminactionlogObject: AdminActionLogObject = adminactionlog.toObject();
 * ```
 */
export type AdminActionLogObject = AdminActionLog

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type AdminActionLogQuery = mongoose.Query<
  any,
  AdminActionLogDocument,
  AdminActionLogQueries
> &
  AdminActionLogQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `AdminActionLogSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type AdminActionLogQueries = {}

export type AdminActionLogMethods = {
  getActionType: (this: AdminActionLogDocument, ...args: any[]) => any
}

export type AdminActionLogStatics = {
  logAction: (this: AdminActionLogModel, ...args: any[]) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const AdminActionLog = mongoose.model<AdminActionLogDocument, AdminActionLogModel>("AdminActionLog", AdminActionLogSchema);
 * ```
 */
export type AdminActionLogModel = mongoose.Model<
  AdminActionLogDocument,
  AdminActionLogQueries
> &
  AdminActionLogStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new AdminActionLog schema instances:
 * ```
 * const AdminActionLogSchema: AdminActionLogSchema = new mongoose.Schema({ ... })
 * ```
 */
export type AdminActionLogSchema = mongoose.Schema<
  AdminActionLogDocument,
  AdminActionLogModel,
  AdminActionLogMethods,
  AdminActionLogQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const AdminActionLog = mongoose.model<AdminActionLogDocument, AdminActionLogModel>("AdminActionLog", AdminActionLogSchema);
 * ```
 */
export type AdminActionLogDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  AdminActionLogQueries
> &
  AdminActionLogMethods & {
    admin: UserDocument["_id"] | UserDocument
    action:
      | "create_user"
      | "delete_user"
      | "update_user_role"
      | "suspend_user"
      | "create_goal"
      | "delete_goal"
      | "modify_subscription"
      | "view_reports"
      | "other"
    description?: string
    target?: UserDocument["_id"] | UserDocument | null
    details?: mongoose.Types.Map<string>
    ipAddress?: string
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
    actionType: string
  }

/**
 * Lean version of AnonymousMilitaryMessageDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `AnonymousMilitaryMessageDocument.toObject()`. To avoid conflicts with model names, use the type alias `AnonymousMilitaryMessageObject`.
 * ```
 * const anonymousmilitarymessageObject = anonymousmilitarymessage.toObject();
 * ```
 */
export type AnonymousMilitaryMessage = {
  room: "veterans-support" | "active-duty" | "family-members"
  anonymousSessionId: string
  displayName: string
  message: string
  isFlagged?: boolean
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of AnonymousMilitaryMessageDocument (type alias of `AnonymousMilitaryMessage`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { AnonymousMilitaryMessage } from "../models"
 * import { AnonymousMilitaryMessageObject } from "../interfaces/mongoose.gen.ts"
 *
 * const anonymousmilitarymessageObject: AnonymousMilitaryMessageObject = anonymousmilitarymessage.toObject();
 * ```
 */
export type AnonymousMilitaryMessageObject = AnonymousMilitaryMessage

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type AnonymousMilitaryMessageQuery = mongoose.Query<
  any,
  AnonymousMilitaryMessageDocument,
  AnonymousMilitaryMessageQueries
> &
  AnonymousMilitaryMessageQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `AnonymousMilitaryMessageSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type AnonymousMilitaryMessageQueries = {}

export type AnonymousMilitaryMessageMethods = {}

export type AnonymousMilitaryMessageStatics = {}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const AnonymousMilitaryMessage = mongoose.model<AnonymousMilitaryMessageDocument, AnonymousMilitaryMessageModel>("AnonymousMilitaryMessage", AnonymousMilitaryMessageSchema);
 * ```
 */
export type AnonymousMilitaryMessageModel = mongoose.Model<
  AnonymousMilitaryMessageDocument,
  AnonymousMilitaryMessageQueries
> &
  AnonymousMilitaryMessageStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new AnonymousMilitaryMessage schema instances:
 * ```
 * const AnonymousMilitaryMessageSchema: AnonymousMilitaryMessageSchema = new mongoose.Schema({ ... })
 * ```
 */
export type AnonymousMilitaryMessageSchema = mongoose.Schema<
  AnonymousMilitaryMessageDocument,
  AnonymousMilitaryMessageModel,
  AnonymousMilitaryMessageMethods,
  AnonymousMilitaryMessageQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const AnonymousMilitaryMessage = mongoose.model<AnonymousMilitaryMessageDocument, AnonymousMilitaryMessageModel>("AnonymousMilitaryMessage", AnonymousMilitaryMessageSchema);
 * ```
 */
export type AnonymousMilitaryMessageDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  AnonymousMilitaryMessageQueries
> &
  AnonymousMilitaryMessageMethods & {
    room: "veterans-support" | "active-duty" | "family-members"
    anonymousSessionId: string
    displayName: string
    message: string
    isFlagged?: boolean
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of AnonymousSessionDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `AnonymousSessionDocument.toObject()`. To avoid conflicts with model names, use the type alias `AnonymousSessionObject`.
 * ```
 * const anonymoussessionObject = anonymoussession.toObject();
 * ```
 */
export type AnonymousSession = {
  sessionId: string
  displayName: string
  room: "veterans-support" | "active-duty" | "family-members"
  lastActive?: Date
  joinedAt?: Date
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of AnonymousSessionDocument (type alias of `AnonymousSession`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { AnonymousSession } from "../models"
 * import { AnonymousSessionObject } from "../interfaces/mongoose.gen.ts"
 *
 * const anonymoussessionObject: AnonymousSessionObject = anonymoussession.toObject();
 * ```
 */
export type AnonymousSessionObject = AnonymousSession

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type AnonymousSessionQuery = mongoose.Query<
  any,
  AnonymousSessionDocument,
  AnonymousSessionQueries
> &
  AnonymousSessionQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `AnonymousSessionSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type AnonymousSessionQueries = {}

export type AnonymousSessionMethods = {}

export type AnonymousSessionStatics = {}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const AnonymousSession = mongoose.model<AnonymousSessionDocument, AnonymousSessionModel>("AnonymousSession", AnonymousSessionSchema);
 * ```
 */
export type AnonymousSessionModel = mongoose.Model<
  AnonymousSessionDocument,
  AnonymousSessionQueries
> &
  AnonymousSessionStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new AnonymousSession schema instances:
 * ```
 * const AnonymousSessionSchema: AnonymousSessionSchema = new mongoose.Schema({ ... })
 * ```
 */
export type AnonymousSessionSchema = mongoose.Schema<
  AnonymousSessionDocument,
  AnonymousSessionModel,
  AnonymousSessionMethods,
  AnonymousSessionQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const AnonymousSession = mongoose.model<AnonymousSessionDocument, AnonymousSessionModel>("AnonymousSession", AnonymousSessionSchema);
 * ```
 */
export type AnonymousSessionDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  AnonymousSessionQueries
> &
  AnonymousSessionMethods & {
    sessionId: string
    displayName: string
    room: "veterans-support" | "active-duty" | "family-members"
    lastActive?: Date
    joinedAt?: Date
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of AnonymousMoodCheckInDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `AnonymousMoodCheckInDocument.toObject()`. To avoid conflicts with model names, use the type alias `AnonymousMoodCheckInObject`.
 * ```
 * const anonymousmoodcheckinObject = anonymousmoodcheckin.toObject();
 * ```
 */
export type AnonymousMoodCheckIn = {
  sessionId: string
  mood: number
  note?: string | null
  ipAddress?: string | null
  userAgent?: string | null
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of AnonymousMoodCheckInDocument (type alias of `AnonymousMoodCheckIn`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { AnonymousMoodCheckIn } from "../models"
 * import { AnonymousMoodCheckInObject } from "../interfaces/mongoose.gen.ts"
 *
 * const anonymousmoodcheckinObject: AnonymousMoodCheckInObject = anonymousmoodcheckin.toObject();
 * ```
 */
export type AnonymousMoodCheckInObject = AnonymousMoodCheckIn

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type AnonymousMoodCheckInQuery = mongoose.Query<
  any,
  AnonymousMoodCheckInDocument,
  AnonymousMoodCheckInQueries
> &
  AnonymousMoodCheckInQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `AnonymousMoodCheckInSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type AnonymousMoodCheckInQueries = {}

export type AnonymousMoodCheckInMethods = {}

export type AnonymousMoodCheckInStatics = {
  getTodaysMoodDistribution: (
    this: AnonymousMoodCheckInModel,
    ...args: any[]
  ) => any
  getMoodTrends: (this: AnonymousMoodCheckInModel, ...args: any[]) => any
  hasSubmittedToday: (this: AnonymousMoodCheckInModel, ...args: any[]) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const AnonymousMoodCheckIn = mongoose.model<AnonymousMoodCheckInDocument, AnonymousMoodCheckInModel>("AnonymousMoodCheckIn", AnonymousMoodCheckInSchema);
 * ```
 */
export type AnonymousMoodCheckInModel = mongoose.Model<
  AnonymousMoodCheckInDocument,
  AnonymousMoodCheckInQueries
> &
  AnonymousMoodCheckInStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new AnonymousMoodCheckIn schema instances:
 * ```
 * const AnonymousMoodCheckInSchema: AnonymousMoodCheckInSchema = new mongoose.Schema({ ... })
 * ```
 */
export type AnonymousMoodCheckInSchema = mongoose.Schema<
  AnonymousMoodCheckInDocument,
  AnonymousMoodCheckInModel,
  AnonymousMoodCheckInMethods,
  AnonymousMoodCheckInQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const AnonymousMoodCheckIn = mongoose.model<AnonymousMoodCheckInDocument, AnonymousMoodCheckInModel>("AnonymousMoodCheckIn", AnonymousMoodCheckInSchema);
 * ```
 */
export type AnonymousMoodCheckInDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  AnonymousMoodCheckInQueries
> &
  AnonymousMoodCheckInMethods & {
    sessionId: string
    mood: number
    note?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of APIKeyDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `APIKeyDocument.toObject()`. To avoid conflicts with model names, use the type alias `APIKeyObject`.
 * ```
 * const apikeyObject = apikey.toObject();
 * ```
 */
export type APIKey = {
  key: string
  owner: User["_id"] | User
  permissions: ("read" | "write" | "delete" | "admin")[]
  isActive?: boolean
  expiresAt: Date
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
  status: string
}

/**
 * Lean version of APIKeyDocument (type alias of `APIKey`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { APIKey } from "../models"
 * import { APIKeyObject } from "../interfaces/mongoose.gen.ts"
 *
 * const apikeyObject: APIKeyObject = apikey.toObject();
 * ```
 */
export type APIKeyObject = APIKey

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type APIKeyQuery = mongoose.Query<any, APIKeyDocument, APIKeyQueries> &
  APIKeyQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `APIKeySchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type APIKeyQueries = {}

export type APIKeyMethods = {
  deactivate: (this: APIKeyDocument, ...args: any[]) => any
  renew: (this: APIKeyDocument, ...args: any[]) => any
  hasPermission: (this: APIKeyDocument, ...args: any[]) => any
}

export type APIKeyStatics = {
  validateKey: (this: APIKeyModel, ...args: any[]) => any
  generateKeyForUser: (this: APIKeyModel, ...args: any[]) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const APIKey = mongoose.model<APIKeyDocument, APIKeyModel>("APIKey", APIKeySchema);
 * ```
 */
export type APIKeyModel = mongoose.Model<APIKeyDocument, APIKeyQueries> &
  APIKeyStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new APIKey schema instances:
 * ```
 * const APIKeySchema: APIKeySchema = new mongoose.Schema({ ... })
 * ```
 */
export type APIKeySchema = mongoose.Schema<
  APIKeyDocument,
  APIKeyModel,
  APIKeyMethods,
  APIKeyQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const APIKey = mongoose.model<APIKeyDocument, APIKeyModel>("APIKey", APIKeySchema);
 * ```
 */
export type APIKeyDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  APIKeyQueries
> &
  APIKeyMethods & {
    key: string
    owner: UserDocument["_id"] | UserDocument
    permissions: mongoose.Types.Array<"read" | "write" | "delete" | "admin">
    isActive?: boolean
    expiresAt: Date
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
    status: string
  }

/**
 * Lean version of AuditTrailDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `AuditTrailDocument.toObject()`. To avoid conflicts with model names, use the type alias `AuditTrailObject`.
 * ```
 * const audittrailObject = audittrail.toObject();
 * ```
 */
export type AuditTrail = {
  userId?: User["_id"] | User | null
  entityType: "User" | "Goal" | "Task" | "Subscription" | "Payment"
  entityId: mongoose.Types.ObjectId
  action: string
  description?: string
  ipAddress?: string
  userAgent?: string
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of AuditTrailDocument (type alias of `AuditTrail`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { AuditTrail } from "../models"
 * import { AuditTrailObject } from "../interfaces/mongoose.gen.ts"
 *
 * const audittrailObject: AuditTrailObject = audittrail.toObject();
 * ```
 */
export type AuditTrailObject = AuditTrail

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type AuditTrailQuery = mongoose.Query<
  any,
  AuditTrailDocument,
  AuditTrailQueries
> &
  AuditTrailQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `AuditTrailSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type AuditTrailQueries = {}

export type AuditTrailMethods = {}

export type AuditTrailStatics = {
  logEvent: (this: AuditTrailModel, ...args: any[]) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const AuditTrail = mongoose.model<AuditTrailDocument, AuditTrailModel>("AuditTrail", AuditTrailSchema);
 * ```
 */
export type AuditTrailModel = mongoose.Model<
  AuditTrailDocument,
  AuditTrailQueries
> &
  AuditTrailStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new AuditTrail schema instances:
 * ```
 * const AuditTrailSchema: AuditTrailSchema = new mongoose.Schema({ ... })
 * ```
 */
export type AuditTrailSchema = mongoose.Schema<
  AuditTrailDocument,
  AuditTrailModel,
  AuditTrailMethods,
  AuditTrailQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const AuditTrail = mongoose.model<AuditTrailDocument, AuditTrailModel>("AuditTrail", AuditTrailSchema);
 * ```
 */
export type AuditTrailDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  AuditTrailQueries
> &
  AuditTrailMethods & {
    userId?: UserDocument["_id"] | UserDocument | null
    entityType: "User" | "Goal" | "Task" | "Subscription" | "Payment"
    entityId: mongoose.Types.ObjectId
    action: string
    description?: string
    ipAddress?: string
    userAgent?: string
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of BadgeDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `BadgeDocument.toObject()`. To avoid conflicts with model names, use the type alias `BadgeObject`.
 * ```
 * const badgeObject = badge.toObject();
 * ```
 */
export type Badge = {
  user: User["_id"] | User
  badgeType: BadgeType["_id"] | BadgeType
  level?: "Bronze" | "Silver" | "Gold"
  progress?: number
  dateAwarded?: Date
  isShowcased?: boolean
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of BadgeDocument (type alias of `Badge`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Badge } from "../models"
 * import { BadgeObject } from "../interfaces/mongoose.gen.ts"
 *
 * const badgeObject: BadgeObject = badge.toObject();
 * ```
 */
export type BadgeObject = Badge

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type BadgeQuery = mongoose.Query<any, BadgeDocument, BadgeQueries> &
  BadgeQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `BadgeSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type BadgeQueries = {}

export type BadgeMethods = {}

export type BadgeStatics = {}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Badge = mongoose.model<BadgeDocument, BadgeModel>("Badge", BadgeSchema);
 * ```
 */
export type BadgeModel = mongoose.Model<BadgeDocument, BadgeQueries> &
  BadgeStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Badge schema instances:
 * ```
 * const BadgeSchema: BadgeSchema = new mongoose.Schema({ ... })
 * ```
 */
export type BadgeSchema = mongoose.Schema<
  BadgeDocument,
  BadgeModel,
  BadgeMethods,
  BadgeQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Badge = mongoose.model<BadgeDocument, BadgeModel>("Badge", BadgeSchema);
 * ```
 */
export type BadgeDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  BadgeQueries
> &
  BadgeMethods & {
    user: UserDocument["_id"] | UserDocument
    badgeType: BadgeTypeDocument["_id"] | BadgeTypeDocument
    level?: "Bronze" | "Silver" | "Gold"
    progress?: number
    dateAwarded?: Date
    isShowcased?: boolean
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of BadgeTypeDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `BadgeTypeDocument.toObject()`. To avoid conflicts with model names, use the type alias `BadgeTypeObject`.
 * ```
 * const badgetypeObject = badgetype.toObject();
 * ```
 */
export type BadgeType = {
  name: string
  description?: string
  bronzePointsToAward?: number
  silverPointsToAward?: number
  goldPointsToAward?: number
  iconKey?: string
  conditionToMeet: "goal_completed" | "consistency_master" | "point_earner"
  bronzeAmountRequired?: number
  silverAmountRequired?: number
  goldAmountRequired?: number
  expiresAt?: Date
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
  isExpired: boolean
}

/**
 * Lean version of BadgeTypeDocument (type alias of `BadgeType`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { BadgeType } from "../models"
 * import { BadgeTypeObject } from "../interfaces/mongoose.gen.ts"
 *
 * const badgetypeObject: BadgeTypeObject = badgetype.toObject();
 * ```
 */
export type BadgeTypeObject = BadgeType

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type BadgeTypeQuery = mongoose.Query<
  any,
  BadgeTypeDocument,
  BadgeTypeQueries
> &
  BadgeTypeQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `BadgeTypeSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type BadgeTypeQueries = {}

export type BadgeTypeMethods = {
  getIconUrl: (this: BadgeTypeDocument) => Promise<string>
}

export type BadgeTypeStatics = {}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const BadgeType = mongoose.model<BadgeTypeDocument, BadgeTypeModel>("BadgeType", BadgeTypeSchema);
 * ```
 */
export type BadgeTypeModel = mongoose.Model<
  BadgeTypeDocument,
  BadgeTypeQueries
> &
  BadgeTypeStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new BadgeType schema instances:
 * ```
 * const BadgeTypeSchema: BadgeTypeSchema = new mongoose.Schema({ ... })
 * ```
 */
export type BadgeTypeSchema = mongoose.Schema<
  BadgeTypeDocument,
  BadgeTypeModel,
  BadgeTypeMethods,
  BadgeTypeQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const BadgeType = mongoose.model<BadgeTypeDocument, BadgeTypeModel>("BadgeType", BadgeTypeSchema);
 * ```
 */
export type BadgeTypeDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  BadgeTypeQueries
> &
  BadgeTypeMethods & {
    name: string
    description?: string
    bronzePointsToAward?: number
    silverPointsToAward?: number
    goldPointsToAward?: number
    iconKey?: string
    conditionToMeet: "goal_completed" | "consistency_master" | "point_earner"
    bronzeAmountRequired?: number
    silverAmountRequired?: number
    goldAmountRequired?: number
    expiresAt?: Date
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
    isExpired: boolean
  }

/**
 * Lean version of BlogPostCommentDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `BlogPostDocument.toObject()`.
 * ```
 * const blogpostObject = blogpost.toObject();
 * ```
 */
export type BlogPostComment = {
  user: User["_id"] | User
  text: string
  createdAt?: Date
  _id: mongoose.Types.ObjectId
}

/**
 * Lean version of BlogPostDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `BlogPostDocument.toObject()`. To avoid conflicts with model names, use the type alias `BlogPostObject`.
 * ```
 * const blogpostObject = blogpost.toObject();
 * ```
 */
export type BlogPost = {
  title: string
  content: string
  category: string
  imageUrl?: string
  author: User["_id"] | User
  likes: (User["_id"] | User)[]
  comments: BlogPostComment[]
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
  likeCount: any
  commentCount: number
}

/**
 * Lean version of BlogPostDocument (type alias of `BlogPost`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { BlogPost } from "../models"
 * import { BlogPostObject } from "../interfaces/mongoose.gen.ts"
 *
 * const blogpostObject: BlogPostObject = blogpost.toObject();
 * ```
 */
export type BlogPostObject = BlogPost

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type BlogPostQuery = mongoose.Query<
  any,
  BlogPostDocument,
  BlogPostQueries
> &
  BlogPostQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `BlogPostSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type BlogPostQueries = {}

export type BlogPostMethods = {
  addLike: (this: BlogPostDocument, ...args: any[]) => any
  removeLike: (this: BlogPostDocument, ...args: any[]) => any
  addComment: (this: BlogPostDocument, ...args: any[]) => any
  removeComment: (this: BlogPostDocument, ...args: any[]) => any
}

export type BlogPostStatics = {
  findByCategory: (this: BlogPostModel, ...args: any[]) => any
  findRecent: (this: BlogPostModel, ...args: any[]) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const BlogPost = mongoose.model<BlogPostDocument, BlogPostModel>("BlogPost", BlogPostSchema);
 * ```
 */
export type BlogPostModel = mongoose.Model<BlogPostDocument, BlogPostQueries> &
  BlogPostStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new BlogPost schema instances:
 * ```
 * const BlogPostSchema: BlogPostSchema = new mongoose.Schema({ ... })
 * ```
 */
export type BlogPostSchema = mongoose.Schema<
  BlogPostDocument,
  BlogPostModel,
  BlogPostMethods,
  BlogPostQueries
>

/**
 * Mongoose Subdocument type
 *
 * Type of `BlogPostDocument["comments"]` element.
 */
export type BlogPostCommentDocument =
  mongoose.Types.Subdocument<mongoose.Types.ObjectId> & {
    user: UserDocument["_id"] | UserDocument
    text: string
    createdAt?: Date
    _id: mongoose.Types.ObjectId
  }

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const BlogPost = mongoose.model<BlogPostDocument, BlogPostModel>("BlogPost", BlogPostSchema);
 * ```
 */
export type BlogPostDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  BlogPostQueries
> &
  BlogPostMethods & {
    title: string
    content: string
    category: string
    imageUrl?: string
    author: UserDocument["_id"] | UserDocument
    likes: mongoose.Types.Array<UserDocument["_id"] | UserDocument>
    comments: mongoose.Types.DocumentArray<BlogPostCommentDocument>
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
    likeCount: any
    commentCount: number
  }

/**
 * Lean version of BookCommentDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `BookDocument.toObject()`.
 * ```
 * const bookObject = book.toObject();
 * ```
 */
export type BookComment = {
  user: User["_id"] | User
  text: string
  createdAt?: Date
  _id: mongoose.Types.ObjectId
}

/**
 * Lean version of BookDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `BookDocument.toObject()`. To avoid conflicts with model names, use the type alias `BookObject`.
 * ```
 * const bookObject = book.toObject();
 * ```
 */
export type Book = {
  title: string
  author: string
  category: string
  description: string
  coverImage?: string
  addedBy: User["_id"] | User
  likes: (User["_id"] | User)[]
  comments: BookComment[]
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
  likeCount: number
  commentCount: number
}

/**
 * Lean version of BookDocument (type alias of `Book`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Book } from "../models"
 * import { BookObject } from "../interfaces/mongoose.gen.ts"
 *
 * const bookObject: BookObject = book.toObject();
 * ```
 */
export type BookObject = Book

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type BookQuery = mongoose.Query<any, BookDocument, BookQueries> &
  BookQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `BookSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type BookQueries = {}

export type BookMethods = {
  addLike: (this: BookDocument, userId: mongoose.Types.ObjectId) => Promise<any>
  removeLike: (
    this: BookDocument,
    userId: mongoose.Types.ObjectId
  ) => Promise<any>
  addComment: (
    this: BookDocument,
    userId: mongoose.Types.ObjectId,
    text: string
  ) => Promise<any>
  removeComment: (
    this: BookDocument,
    commentId: mongoose.Types.ObjectId
  ) => Promise<boolean>
}

export type BookStatics = {
  findByCategory: (this: BookModel, category: string, limit?: number) => any
  findRecent: (this: BookModel, limit?: number) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Book = mongoose.model<BookDocument, BookModel>("Book", BookSchema);
 * ```
 */
export type BookModel = mongoose.Model<BookDocument, BookQueries> & BookStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Book schema instances:
 * ```
 * const BookSchema: BookSchema = new mongoose.Schema({ ... })
 * ```
 */
export type BookSchema = mongoose.Schema<
  BookDocument,
  BookModel,
  BookMethods,
  BookQueries
>

/**
 * Mongoose Subdocument type
 *
 * Type of `BookDocument["comments"]` element.
 */
export type BookCommentDocument =
  mongoose.Types.Subdocument<mongoose.Types.ObjectId> & {
    user: UserDocument["_id"] | UserDocument
    text: string
    createdAt?: Date
    _id: mongoose.Types.ObjectId
  }

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Book = mongoose.model<BookDocument, BookModel>("Book", BookSchema);
 * ```
 */
export type BookDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  BookQueries
> &
  BookMethods & {
    title: string
    author: string
    category: string
    description: string
    coverImage?: string
    addedBy: UserDocument["_id"] | UserDocument
    likes: mongoose.Types.Array<UserDocument["_id"] | UserDocument>
    comments: mongoose.Types.DocumentArray<BookCommentDocument>
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
    likeCount: number
    commentCount: number
  }

/**
 * Lean version of ChallengeParticipantDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `ChallengeDocument.toObject()`.
 * ```
 * const challengeObject = challenge.toObject();
 * ```
 */
export type ChallengeParticipant = {
  user: User["_id"] | User
  progress?: number
  joinedAt?: Date
  _id: mongoose.Types.ObjectId
}

/**
 * Lean version of ChallengeDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `ChallengeDocument.toObject()`. To avoid conflicts with model names, use the type alias `ChallengeObject`.
 * ```
 * const challengeObject = challenge.toObject();
 * ```
 */
export type Challenge = {
  title: string
  description?: string
  goal: string
  startDate?: Date
  endDate: Date
  creator: User["_id"] | User
  participants: ChallengeParticipant[]
  rewards: (Reward["_id"] | Reward)[]
  status?: "ongoing" | "completed" | "canceled"
  visibility?: "public" | "private"
  progressTracking?: "individual" | "team" | "both"
  milestones: (Milestone["_id"] | Milestone)[]
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
  participantCount: any
  isActive: boolean
}

/**
 * Lean version of ChallengeDocument (type alias of `Challenge`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Challenge } from "../models"
 * import { ChallengeObject } from "../interfaces/mongoose.gen.ts"
 *
 * const challengeObject: ChallengeObject = challenge.toObject();
 * ```
 */
export type ChallengeObject = Challenge

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type ChallengeQuery = mongoose.Query<
  any,
  ChallengeDocument,
  ChallengeQueries
> &
  ChallengeQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `ChallengeSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type ChallengeQueries = {}

export type ChallengeMethods = {
  addReward: (
    this: ChallengeDocument,
    rewardType: RewardObject,
    rewardValue: string
  ) => Promise<any>
  addMilestone: (
    this: ChallengeDocument,
    milestoneTitle: string,
    dueDate: Date
  ) => Promise<any>
}

export type ChallengeStatics = {
  addParticipant: (
    this: ChallengeModel,
    challengeId: mongoose.Types.ObjectId,
    userId: mongoose.Types.ObjectId
  ) => Promise<any>
  updateProgress: (
    this: ChallengeModel,
    challengeId: mongoose.Types.ObjectId,
    userId: mongoose.Types.ObjectId,
    progressUpdate: number
  ) => Promise<any>
  updateMilestoneStatus: (
    this: ChallengeModel,
    challengeId: mongoose.Types.ObjectId,
    milestoneId: mongoose.Types.ObjectId
  ) => Promise<void>
  fetchChallengesWithPagination: (
    this: ChallengeModel,
    page: number,
    pageSize: number,
    filters?: Record<string, any>
  ) => Promise<any>
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Challenge = mongoose.model<ChallengeDocument, ChallengeModel>("Challenge", ChallengeSchema);
 * ```
 */
export type ChallengeModel = mongoose.Model<
  ChallengeDocument,
  ChallengeQueries
> &
  ChallengeStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Challenge schema instances:
 * ```
 * const ChallengeSchema: ChallengeSchema = new mongoose.Schema({ ... })
 * ```
 */
export type ChallengeSchema = mongoose.Schema<
  ChallengeDocument,
  ChallengeModel,
  ChallengeMethods,
  ChallengeQueries
>

/**
 * Mongoose Subdocument type
 *
 * Type of `ChallengeDocument["participants"]` element.
 */
export type ChallengeParticipantDocument =
  mongoose.Types.Subdocument<mongoose.Types.ObjectId> & {
    user: UserDocument["_id"] | UserDocument
    progress?: number
    joinedAt?: Date
    _id: mongoose.Types.ObjectId
  }

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Challenge = mongoose.model<ChallengeDocument, ChallengeModel>("Challenge", ChallengeSchema);
 * ```
 */
export type ChallengeDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  ChallengeQueries
> &
  ChallengeMethods & {
    title: string
    description?: string
    goal: string
    startDate?: Date
    endDate: Date
    creator: UserDocument["_id"] | UserDocument
    participants: mongoose.Types.DocumentArray<ChallengeParticipantDocument>
    rewards: mongoose.Types.Array<RewardDocument["_id"] | RewardDocument>
    status?: "ongoing" | "completed" | "canceled"
    visibility?: "public" | "private"
    progressTracking?: "individual" | "team" | "both"
    milestones: mongoose.Types.Array<
      MilestoneDocument["_id"] | MilestoneDocument
    >
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
    participantCount: any
    isActive: boolean
  }

/**
 * Lean version of ChallengeMilestoneDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `ChallengeMilestoneDocument.toObject()`. To avoid conflicts with model names, use the type alias `ChallengeMilestoneObject`.
 * ```
 * const challengemilestoneObject = challengemilestone.toObject();
 * ```
 */
export type ChallengeMilestone = {
  challenge: Challenge["_id"] | Challenge
  title: string
  dueDate: Date
  completed?: boolean
  achievedBy: (User["_id"] | User)[]
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
  isOverdue: boolean
}

/**
 * Lean version of ChallengeMilestoneDocument (type alias of `ChallengeMilestone`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { ChallengeMilestone } from "../models"
 * import { ChallengeMilestoneObject } from "../interfaces/mongoose.gen.ts"
 *
 * const challengemilestoneObject: ChallengeMilestoneObject = challengemilestone.toObject();
 * ```
 */
export type ChallengeMilestoneObject = ChallengeMilestone

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type ChallengeMilestoneQuery = mongoose.Query<
  any,
  ChallengeMilestoneDocument,
  ChallengeMilestoneQueries
> &
  ChallengeMilestoneQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `ChallengeMilestoneSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type ChallengeMilestoneQueries = {}

export type ChallengeMilestoneMethods = {
  markComplete: (this: ChallengeMilestoneDocument, ...args: any[]) => any
  reset: (this: ChallengeMilestoneDocument, ...args: any[]) => any
}

export type ChallengeMilestoneStatics = {
  getByChallenge: (this: ChallengeMilestoneModel, ...args: any[]) => any
  getPending: (this: ChallengeMilestoneModel, ...args: any[]) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const ChallengeMilestone = mongoose.model<ChallengeMilestoneDocument, ChallengeMilestoneModel>("ChallengeMilestone", ChallengeMilestoneSchema);
 * ```
 */
export type ChallengeMilestoneModel = mongoose.Model<
  ChallengeMilestoneDocument,
  ChallengeMilestoneQueries
> &
  ChallengeMilestoneStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new ChallengeMilestone schema instances:
 * ```
 * const ChallengeMilestoneSchema: ChallengeMilestoneSchema = new mongoose.Schema({ ... })
 * ```
 */
export type ChallengeMilestoneSchema = mongoose.Schema<
  ChallengeMilestoneDocument,
  ChallengeMilestoneModel,
  ChallengeMilestoneMethods,
  ChallengeMilestoneQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const ChallengeMilestone = mongoose.model<ChallengeMilestoneDocument, ChallengeMilestoneModel>("ChallengeMilestone", ChallengeMilestoneSchema);
 * ```
 */
export type ChallengeMilestoneDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  ChallengeMilestoneQueries
> &
  ChallengeMilestoneMethods & {
    challenge: ChallengeDocument["_id"] | ChallengeDocument
    title: string
    dueDate: Date
    completed?: boolean
    achievedBy: mongoose.Types.Array<UserDocument["_id"] | UserDocument>
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
    isOverdue: boolean
  }

/**
 * Lean version of ChallengeParticipationDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `ChallengeParticipationDocument.toObject()`. To avoid conflicts with model names, use the type alias `ChallengeParticipationObject`.
 * ```
 * const challengeparticipationObject = challengeparticipation.toObject();
 * ```
 */
export type ChallengeParticipation = {
  user: User["_id"] | User
  challenge: Challenge["_id"] | Challenge
  joinedAt?: Date
  progress?: number
  completed?: boolean
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
  progressPercent: number
}

/**
 * Lean version of ChallengeParticipationDocument (type alias of `ChallengeParticipation`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { ChallengeParticipation } from "../models"
 * import { ChallengeParticipationObject } from "../interfaces/mongoose.gen.ts"
 *
 * const challengeparticipationObject: ChallengeParticipationObject = challengeparticipation.toObject();
 * ```
 */
export type ChallengeParticipationObject = ChallengeParticipation

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type ChallengeParticipationQuery = mongoose.Query<
  any,
  ChallengeParticipationDocument,
  ChallengeParticipationQueries
> &
  ChallengeParticipationQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `ChallengeParticipationSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type ChallengeParticipationQueries = {}

export type ChallengeParticipationMethods = {
  updateProgress: (this: ChallengeParticipationDocument, ...args: any[]) => any
  markComplete: (this: ChallengeParticipationDocument, ...args: any[]) => any
  resetProgress: (this: ChallengeParticipationDocument, ...args: any[]) => any
}

export type ChallengeParticipationStatics = {
  getUserParticipation: (
    this: ChallengeParticipationModel,
    ...args: any[]
  ) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const ChallengeParticipation = mongoose.model<ChallengeParticipationDocument, ChallengeParticipationModel>("ChallengeParticipation", ChallengeParticipationSchema);
 * ```
 */
export type ChallengeParticipationModel = mongoose.Model<
  ChallengeParticipationDocument,
  ChallengeParticipationQueries
> &
  ChallengeParticipationStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new ChallengeParticipation schema instances:
 * ```
 * const ChallengeParticipationSchema: ChallengeParticipationSchema = new mongoose.Schema({ ... })
 * ```
 */
export type ChallengeParticipationSchema = mongoose.Schema<
  ChallengeParticipationDocument,
  ChallengeParticipationModel,
  ChallengeParticipationMethods,
  ChallengeParticipationQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const ChallengeParticipation = mongoose.model<ChallengeParticipationDocument, ChallengeParticipationModel>("ChallengeParticipation", ChallengeParticipationSchema);
 * ```
 */
export type ChallengeParticipationDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  ChallengeParticipationQueries
> &
  ChallengeParticipationMethods & {
    user: UserDocument["_id"] | UserDocument
    challenge: ChallengeDocument["_id"] | ChallengeDocument
    joinedAt?: Date
    progress?: number
    completed?: boolean
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
    progressPercent: number
  }

/**
 * Lean version of ChatUnreadMessageDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `ChatDocument.toObject()`.
 * ```
 * const chatObject = chat.toObject();
 * ```
 */
export type ChatUnreadMessage = {
  userId: User["_id"] | User
  count?: number
  _id: mongoose.Types.ObjectId
}

/**
 * Lean version of ChatDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `ChatDocument.toObject()`. To avoid conflicts with model names, use the type alias `ChatObject`.
 * ```
 * const chatObject = chat.toObject();
 * ```
 */
export type Chat = {
  participants: (User["_id"] | User)[]
  messages: (Message["_id"] | Message)[]
  chatType: "private" | "group"
  groupName?: string | null
  chatAvatar?: string | null
  unreadMessages: ChatUnreadMessage[]
  lastMessage?: Message["_id"] | Message
  typingUsers: (User["_id"] | User)[]
  isPinned?: boolean
  admins: (User["_id"] | User)[]
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
  participantCount: number
  messageCount: number
}

/**
 * Lean version of ChatDocument (type alias of `Chat`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Chat } from "../models"
 * import { ChatObject } from "../interfaces/mongoose.gen.ts"
 *
 * const chatObject: ChatObject = chat.toObject();
 * ```
 */
export type ChatObject = Chat

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type ChatQuery = mongoose.Query<any, ChatDocument, ChatQueries> &
  ChatQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `ChatSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type ChatQueries = {}

export type ChatMethods = {
  addMessage: (this: ChatDocument, ...args: any[]) => any
  markRead: (this: ChatDocument, ...args: any[]) => any
  addTypingUser: (this: ChatDocument, ...args: any[]) => any
  removeTypingUser: (this: ChatDocument, ...args: any[]) => any
  pin: (this: ChatDocument, ...args: any[]) => any
  unpin: (this: ChatDocument, ...args: any[]) => any
}

export type ChatStatics = {
  getUserChats: (this: ChatModel, ...args: any[]) => any
  getGroupChats: (this: ChatModel, ...args: any[]) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Chat = mongoose.model<ChatDocument, ChatModel>("Chat", ChatSchema);
 * ```
 */
export type ChatModel = mongoose.Model<ChatDocument, ChatQueries> & ChatStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Chat schema instances:
 * ```
 * const ChatSchema: ChatSchema = new mongoose.Schema({ ... })
 * ```
 */
export type ChatSchema = mongoose.Schema<
  ChatDocument,
  ChatModel,
  ChatMethods,
  ChatQueries
>

/**
 * Mongoose Subdocument type
 *
 * Type of `ChatDocument["unreadMessages"]` element.
 */
export type ChatUnreadMessageDocument =
  mongoose.Types.Subdocument<mongoose.Types.ObjectId> & {
    userId: UserDocument["_id"] | UserDocument
    count?: number
    _id: mongoose.Types.ObjectId
  }

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Chat = mongoose.model<ChatDocument, ChatModel>("Chat", ChatSchema);
 * ```
 */
export type ChatDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  ChatQueries
> &
  ChatMethods & {
    participants: mongoose.Types.Array<UserDocument["_id"] | UserDocument>
    messages: mongoose.Types.Array<MessageDocument["_id"] | MessageDocument>
    chatType: "private" | "group"
    groupName?: string | null
    chatAvatar?: string | null
    unreadMessages: mongoose.Types.DocumentArray<ChatUnreadMessageDocument>
    lastMessage?: MessageDocument["_id"] | MessageDocument
    typingUsers: mongoose.Types.Array<UserDocument["_id"] | UserDocument>
    isPinned?: boolean
    admins: mongoose.Types.Array<UserDocument["_id"] | UserDocument>
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
    participantCount: number
    messageCount: number
  }

/**
 * Lean version of CheckInDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `CheckInDocument.toObject()`. To avoid conflicts with model names, use the type alias `CheckInObject`.
 * ```
 * const checkinObject = checkin.toObject();
 * ```
 */
export type CheckIn = {
  user: User["_id"] | User
  createdAt?: Date
  _id: mongoose.Types.ObjectId
}

/**
 * Lean version of CheckInDocument (type alias of `CheckIn`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { CheckIn } from "../models"
 * import { CheckInObject } from "../interfaces/mongoose.gen.ts"
 *
 * const checkinObject: CheckInObject = checkin.toObject();
 * ```
 */
export type CheckInObject = CheckIn

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type CheckInQuery = mongoose.Query<
  any,
  CheckInDocument,
  CheckInQueries
> &
  CheckInQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `CheckInSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type CheckInQueries = {}

export type CheckInMethods = {}

export type CheckInStatics = {}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const CheckIn = mongoose.model<CheckInDocument, CheckInModel>("CheckIn", CheckInSchema);
 * ```
 */
export type CheckInModel = mongoose.Model<CheckInDocument, CheckInQueries> &
  CheckInStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new CheckIn schema instances:
 * ```
 * const CheckInSchema: CheckInSchema = new mongoose.Schema({ ... })
 * ```
 */
export type CheckInSchema = mongoose.Schema<
  CheckInDocument,
  CheckInModel,
  CheckInMethods,
  CheckInQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const CheckIn = mongoose.model<CheckInDocument, CheckInModel>("CheckIn", CheckInSchema);
 * ```
 */
export type CheckInDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  CheckInQueries
> &
  CheckInMethods & {
    user: UserDocument["_id"] | UserDocument
    createdAt?: Date
    _id: mongoose.Types.ObjectId
  }

/**
 * Lean version of CollaborationGoalDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `CollaborationGoalDocument.toObject()`. To avoid conflicts with model names, use the type alias `CollaborationGoalObject`.
 * ```
 * const collaborationgoalObject = collaborationgoal.toObject();
 * ```
 */
export type CollaborationGoal = {
  title: string
  description?: string
  status?: "not-started" | "in-progress" | "completed" | "archived"
  progress?: number
  completedAt?: Date
  milestones: (Milestone["_id"] | Milestone)[]
  visibility?: "public" | "private"
  createdBy: User["_id"] | User
  participants: (User["_id"] | User)[]
  target: number
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
  participantCount: any
  milestoneCount: any
}

/**
 * Lean version of CollaborationGoalDocument (type alias of `CollaborationGoal`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { CollaborationGoal } from "../models"
 * import { CollaborationGoalObject } from "../interfaces/mongoose.gen.ts"
 *
 * const collaborationgoalObject: CollaborationGoalObject = collaborationgoal.toObject();
 * ```
 */
export type CollaborationGoalObject = CollaborationGoal

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type CollaborationGoalQuery = mongoose.Query<
  any,
  CollaborationGoalDocument,
  CollaborationGoalQueries
> &
  CollaborationGoalQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `CollaborationGoalSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type CollaborationGoalQueries = {}

export type CollaborationGoalMethods = {
  updateProgress: (
    this: CollaborationGoalDocument,
    newProgress: number
  ) => Promise<any>
  addParticipant: (
    this: CollaborationGoalDocument,
    userId: mongoose.Types.ObjectId
  ) => Promise<any>
  completeMilestone: (
    this: CollaborationGoalDocument,
    index: number
  ) => Promise<any>
}

export type CollaborationGoalStatics = {
  fetchByVisibility: (
    this: CollaborationGoalModel,
    visibility: "public" | "private",
    limit?: number
  ) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const CollaborationGoal = mongoose.model<CollaborationGoalDocument, CollaborationGoalModel>("CollaborationGoal", CollaborationGoalSchema);
 * ```
 */
export type CollaborationGoalModel = mongoose.Model<
  CollaborationGoalDocument,
  CollaborationGoalQueries
> &
  CollaborationGoalStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new CollaborationGoal schema instances:
 * ```
 * const CollaborationGoalSchema: CollaborationGoalSchema = new mongoose.Schema({ ... })
 * ```
 */
export type CollaborationGoalSchema = mongoose.Schema<
  CollaborationGoalDocument,
  CollaborationGoalModel,
  CollaborationGoalMethods,
  CollaborationGoalQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const CollaborationGoal = mongoose.model<CollaborationGoalDocument, CollaborationGoalModel>("CollaborationGoal", CollaborationGoalSchema);
 * ```
 */
export type CollaborationGoalDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  CollaborationGoalQueries
> &
  CollaborationGoalMethods & {
    title: string
    description?: string
    status?: "not-started" | "in-progress" | "completed" | "archived"
    progress?: number
    completedAt?: Date
    milestones: mongoose.Types.Array<
      MilestoneDocument["_id"] | MilestoneDocument
    >
    visibility?: "public" | "private"
    createdBy: UserDocument["_id"] | UserDocument
    participants: mongoose.Types.Array<UserDocument["_id"] | UserDocument>
    target: number
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
    participantCount: any
    milestoneCount: any
  }

/**
 * Lean version of CommentDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `CommentDocument.toObject()`. To avoid conflicts with model names, use the type alias `CommentObject`.
 * ```
 * const commentObject = comment.toObject();
 * ```
 */
export type Comment = {
  author: User["_id"] | User
  text: string
  entityType: "BlogPost" | "FeedPost" | "Book" | "Event" | "Message"
  entityId: mongoose.Types.ObjectId
  parentComment?: Comment["_id"] | Comment | null
  likes: (User["_id"] | User)[]
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
  likeCount: number
}

/**
 * Lean version of CommentDocument (type alias of `Comment`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Comment } from "../models"
 * import { CommentObject } from "../interfaces/mongoose.gen.ts"
 *
 * const commentObject: CommentObject = comment.toObject();
 * ```
 */
export type CommentObject = Comment

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type CommentQuery = mongoose.Query<
  any,
  CommentDocument,
  CommentQueries
> &
  CommentQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `CommentSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type CommentQueries = {}

export type CommentMethods = {
  addLike: (this: CommentDocument, ...args: any[]) => any
  removeLike: (this: CommentDocument, ...args: any[]) => any
}

export type CommentStatics = {
  getByEntity: (this: CommentModel, ...args: any[]) => any
  getReplies: (this: CommentModel, ...args: any[]) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Comment = mongoose.model<CommentDocument, CommentModel>("Comment", CommentSchema);
 * ```
 */
export type CommentModel = mongoose.Model<CommentDocument, CommentQueries> &
  CommentStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Comment schema instances:
 * ```
 * const CommentSchema: CommentSchema = new mongoose.Schema({ ... })
 * ```
 */
export type CommentSchema = mongoose.Schema<
  CommentDocument,
  CommentModel,
  CommentMethods,
  CommentQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Comment = mongoose.model<CommentDocument, CommentModel>("Comment", CommentSchema);
 * ```
 */
export type CommentDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  CommentQueries
> &
  CommentMethods & {
    author: UserDocument["_id"] | UserDocument
    text: string
    entityType: "BlogPost" | "FeedPost" | "Book" | "Event" | "Message"
    entityId: mongoose.Types.ObjectId
    parentComment?: CommentDocument["_id"] | CommentDocument | null
    likes: mongoose.Types.Array<UserDocument["_id"] | UserDocument>
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
    likeCount: number
  }

/**
 * Lean version of CustomReminderDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `CustomReminderDocument.toObject()`. To avoid conflicts with model names, use the type alias `CustomReminderObject`.
 * ```
 * const customreminderObject = customreminder.toObject();
 * ```
 */
export type CustomReminder = {
  user: User["_id"] | User
  reminderMessage: string
  remindAt: Date
  recurrence?: string | null
  disabled?: boolean
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of CustomReminderDocument (type alias of `CustomReminder`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { CustomReminder } from "../models"
 * import { CustomReminderObject } from "../interfaces/mongoose.gen.ts"
 *
 * const customreminderObject: CustomReminderObject = customreminder.toObject();
 * ```
 */
export type CustomReminderObject = CustomReminder

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type CustomReminderQuery = mongoose.Query<
  any,
  CustomReminderDocument,
  CustomReminderQueries
> &
  CustomReminderQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `CustomReminderSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type CustomReminderQueries = {}

export type CustomReminderMethods = {}

export type CustomReminderStatics = {}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const CustomReminder = mongoose.model<CustomReminderDocument, CustomReminderModel>("CustomReminder", CustomReminderSchema);
 * ```
 */
export type CustomReminderModel = mongoose.Model<
  CustomReminderDocument,
  CustomReminderQueries
> &
  CustomReminderStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new CustomReminder schema instances:
 * ```
 * const CustomReminderSchema: CustomReminderSchema = new mongoose.Schema({ ... })
 * ```
 */
export type CustomReminderSchema = mongoose.Schema<
  CustomReminderDocument,
  CustomReminderModel,
  CustomReminderMethods,
  CustomReminderQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const CustomReminder = mongoose.model<CustomReminderDocument, CustomReminderModel>("CustomReminder", CustomReminderSchema);
 * ```
 */
export type CustomReminderDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  CustomReminderQueries
> &
  CustomReminderMethods & {
    user: UserDocument["_id"] | UserDocument
    reminderMessage: string
    remindAt: Date
    recurrence?: string | null
    disabled?: boolean
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of EventParticipantDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `EventDocument.toObject()`.
 * ```
 * const eventObject = event.toObject();
 * ```
 */
export type EventParticipant = {
  user: User["_id"] | User
  joinedAt?: Date
  status?: "invited" | "accepted" | "declined" | "interested"
}

/**
 * Lean version of EventReminderDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `EventDocument.toObject()`.
 * ```
 * const eventObject = event.toObject();
 * ```
 */
export type EventReminder = {
  message: string
  scheduledTime: Date
  sent?: boolean
}

/**
 * Lean version of EventDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `EventDocument.toObject()`. To avoid conflicts with model names, use the type alias `EventObject`.
 * ```
 * const eventObject = event.toObject();
 * ```
 */
export type Event = {
  title: string
  description?: string
  location?: string
  startDate: Date
  endDate: Date
  createdBy: User["_id"] | User
  participants: EventParticipant[]
  progress?: number
  recurrence?: "none" | "daily" | "weekly" | "monthly" | "yearly"
  status?: "upcoming" | "ongoing" | "completed" | "canceled"
  isPublic?: boolean
  reminders: EventReminder[]
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
  participantCount: number
  activeReminderCount: number
}

/**
 * Lean version of EventDocument (type alias of `Event`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Event } from "../models"
 * import { EventObject } from "../interfaces/mongoose.gen.ts"
 *
 * const eventObject: EventObject = event.toObject();
 * ```
 */
export type EventObject = Event

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type EventQuery = mongoose.Query<any, EventDocument, EventQueries> &
  EventQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `EventSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type EventQueries = {}

export type EventMethods = {
  addReminder: (this: EventDocument, ...args: any[]) => any
  getActiveReminders: (this: EventDocument, ...args: any[]) => any
}

export type EventStatics = {
  addParticipant: (this: EventModel, ...args: any[]) => any
  removeParticipant: (this: EventModel, ...args: any[]) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Event = mongoose.model<EventDocument, EventModel>("Event", EventSchema);
 * ```
 */
export type EventModel = mongoose.Model<EventDocument, EventQueries> &
  EventStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Event schema instances:
 * ```
 * const EventSchema: EventSchema = new mongoose.Schema({ ... })
 * ```
 */
export type EventSchema = mongoose.Schema<
  EventDocument,
  EventModel,
  EventMethods,
  EventQueries
>

/**
 * Mongoose Subdocument type
 *
 * Type of `EventDocument["participants"]` element.
 */
export type EventParticipantDocument = mongoose.Types.Subdocument<any> & {
  user: UserDocument["_id"] | UserDocument
  joinedAt?: Date
  status?: "invited" | "accepted" | "declined" | "interested"
}

/**
 * Mongoose Subdocument type
 *
 * Type of `EventDocument["reminders"]` element.
 */
export type EventReminderDocument = mongoose.Types.Subdocument<any> & {
  message: string
  scheduledTime: Date
  sent?: boolean
}

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Event = mongoose.model<EventDocument, EventModel>("Event", EventSchema);
 * ```
 */
export type EventDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  EventQueries
> &
  EventMethods & {
    title: string
    description?: string
    location?: string
    startDate: Date
    endDate: Date
    createdBy: UserDocument["_id"] | UserDocument
    participants: mongoose.Types.DocumentArray<EventParticipantDocument>
    progress?: number
    recurrence?: "none" | "daily" | "weekly" | "monthly" | "yearly"
    status?: "upcoming" | "ongoing" | "completed" | "canceled"
    isPublic?: boolean
    reminders: mongoose.Types.DocumentArray<EventReminderDocument>
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
    participantCount: number
    activeReminderCount: number
  }

/**
 * Lean version of FaqDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `FaqDocument.toObject()`. To avoid conflicts with model names, use the type alias `FaqObject`.
 * ```
 * const faqObject = faq.toObject();
 * ```
 */
export type Faq = {
  question: string
  answer: string
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of FaqDocument (type alias of `Faq`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Faq } from "../models"
 * import { FaqObject } from "../interfaces/mongoose.gen.ts"
 *
 * const faqObject: FaqObject = faq.toObject();
 * ```
 */
export type FaqObject = Faq

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type FaqQuery = mongoose.Query<any, FaqDocument, FaqQueries> & FaqQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `FaqSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type FaqQueries = {}

export type FaqMethods = {}

export type FaqStatics = {}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Faq = mongoose.model<FaqDocument, FaqModel>("Faq", FaqSchema);
 * ```
 */
export type FaqModel = mongoose.Model<FaqDocument, FaqQueries> & FaqStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Faq schema instances:
 * ```
 * const FaqSchema: FaqSchema = new mongoose.Schema({ ... })
 * ```
 */
export type FaqSchema = mongoose.Schema<
  FaqDocument,
  FaqModel,
  FaqMethods,
  FaqQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Faq = mongoose.model<FaqDocument, FaqModel>("Faq", FaqSchema);
 * ```
 */
export type FaqDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  FaqQueries
> &
  FaqMethods & {
    question: string
    answer: string
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of FeedbackDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `FeedbackDocument.toObject()`. To avoid conflicts with model names, use the type alias `FeedbackObject`.
 * ```
 * const feedbackObject = feedback.toObject();
 * ```
 */
export type Feedback = {
  userId: User["_id"] | User
  message: string
  type?: "bug" | "feature-request" | "other"
  status?: "pending" | "reviewed" | "resolved"
  priority?: "low" | "medium" | "high"
  isAnonymous?: boolean
  relatedFeature?: string
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of FeedbackDocument (type alias of `Feedback`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Feedback } from "../models"
 * import { FeedbackObject } from "../interfaces/mongoose.gen.ts"
 *
 * const feedbackObject: FeedbackObject = feedback.toObject();
 * ```
 */
export type FeedbackObject = Feedback

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type FeedbackQuery = mongoose.Query<
  any,
  FeedbackDocument,
  FeedbackQueries
> &
  FeedbackQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `FeedbackSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type FeedbackQueries = {}

export type FeedbackMethods = {
  markAsReviewed: (this: FeedbackDocument, ...args: any[]) => any
}

export type FeedbackStatics = {
  getFeedbackByType: (this: FeedbackModel, ...args: any[]) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Feedback = mongoose.model<FeedbackDocument, FeedbackModel>("Feedback", FeedbackSchema);
 * ```
 */
export type FeedbackModel = mongoose.Model<FeedbackDocument, FeedbackQueries> &
  FeedbackStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Feedback schema instances:
 * ```
 * const FeedbackSchema: FeedbackSchema = new mongoose.Schema({ ... })
 * ```
 */
export type FeedbackSchema = mongoose.Schema<
  FeedbackDocument,
  FeedbackModel,
  FeedbackMethods,
  FeedbackQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Feedback = mongoose.model<FeedbackDocument, FeedbackModel>("Feedback", FeedbackSchema);
 * ```
 */
export type FeedbackDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  FeedbackQueries
> &
  FeedbackMethods & {
    userId: UserDocument["_id"] | UserDocument
    message: string
    type?: "bug" | "feature-request" | "other"
    status?: "pending" | "reviewed" | "resolved"
    priority?: "low" | "medium" | "high"
    isAnonymous?: boolean
    relatedFeature?: string
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of FeedPostCommentDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `FeedPostDocument.toObject()`.
 * ```
 * const feedpostObject = feedpost.toObject();
 * ```
 */
export type FeedPostComment = {
  user: User["_id"] | User
  text: string
  createdAt?: Date
  _id: mongoose.Types.ObjectId
}

/**
 * Lean version of FeedPostDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `FeedPostDocument.toObject()`. To avoid conflicts with model names, use the type alias `FeedPostObject`.
 * ```
 * const feedpostObject = feedpost.toObject();
 * ```
 */
export type FeedPost = {
  user: User["_id"] | User
  content: string
  likes: (User["_id"] | User)[]
  comments: FeedPostComment[]
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
  likeCount: number
  commentCount: number
}

/**
 * Lean version of FeedPostDocument (type alias of `FeedPost`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { FeedPost } from "../models"
 * import { FeedPostObject } from "../interfaces/mongoose.gen.ts"
 *
 * const feedpostObject: FeedPostObject = feedpost.toObject();
 * ```
 */
export type FeedPostObject = FeedPost

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type FeedPostQuery = mongoose.Query<
  any,
  FeedPostDocument,
  FeedPostQueries
> &
  FeedPostQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `FeedPostSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type FeedPostQueries = {}

export type FeedPostMethods = {
  addLike: (this: FeedPostDocument, ...args: any[]) => any
  removeLike: (this: FeedPostDocument, ...args: any[]) => any
  addComment: (this: FeedPostDocument, ...args: any[]) => any
  removeComment: (this: FeedPostDocument, ...args: any[]) => any
}

export type FeedPostStatics = {
  findByUser: (this: FeedPostModel, ...args: any[]) => any
  findRecent: (this: FeedPostModel, ...args: any[]) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const FeedPost = mongoose.model<FeedPostDocument, FeedPostModel>("FeedPost", FeedPostSchema);
 * ```
 */
export type FeedPostModel = mongoose.Model<FeedPostDocument, FeedPostQueries> &
  FeedPostStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new FeedPost schema instances:
 * ```
 * const FeedPostSchema: FeedPostSchema = new mongoose.Schema({ ... })
 * ```
 */
export type FeedPostSchema = mongoose.Schema<
  FeedPostDocument,
  FeedPostModel,
  FeedPostMethods,
  FeedPostQueries
>

/**
 * Mongoose Subdocument type
 *
 * Type of `FeedPostDocument["comments"]` element.
 */
export type FeedPostCommentDocument =
  mongoose.Types.Subdocument<mongoose.Types.ObjectId> & {
    user: UserDocument["_id"] | UserDocument
    text: string
    createdAt?: Date
    _id: mongoose.Types.ObjectId
  }

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const FeedPost = mongoose.model<FeedPostDocument, FeedPostModel>("FeedPost", FeedPostSchema);
 * ```
 */
export type FeedPostDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  FeedPostQueries
> &
  FeedPostMethods & {
    user: UserDocument["_id"] | UserDocument
    content: string
    likes: mongoose.Types.Array<UserDocument["_id"] | UserDocument>
    comments: mongoose.Types.DocumentArray<FeedPostCommentDocument>
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
    likeCount: number
    commentCount: number
  }

/**
 * Lean version of FollowDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `FollowDocument.toObject()`. To avoid conflicts with model names, use the type alias `FollowObject`.
 * ```
 * const followObject = follow.toObject();
 * ```
 */
export type Follow = {
  follower: User["_id"] | User
  following: User["_id"] | User
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of FollowDocument (type alias of `Follow`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Follow } from "../models"
 * import { FollowObject } from "../interfaces/mongoose.gen.ts"
 *
 * const followObject: FollowObject = follow.toObject();
 * ```
 */
export type FollowObject = Follow

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type FollowQuery = mongoose.Query<any, FollowDocument, FollowQueries> &
  FollowQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `FollowSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type FollowQueries = {}

export type FollowMethods = {}

export type FollowStatics = {
  getFollowers: (this: FollowModel, ...args: any[]) => any
  getFollowings: (this: FollowModel, ...args: any[]) => any
  unfollow: (this: FollowModel, ...args: any[]) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Follow = mongoose.model<FollowDocument, FollowModel>("Follow", FollowSchema);
 * ```
 */
export type FollowModel = mongoose.Model<FollowDocument, FollowQueries> &
  FollowStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Follow schema instances:
 * ```
 * const FollowSchema: FollowSchema = new mongoose.Schema({ ... })
 * ```
 */
export type FollowSchema = mongoose.Schema<
  FollowDocument,
  FollowModel,
  FollowMethods,
  FollowQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Follow = mongoose.model<FollowDocument, FollowModel>("Follow", FollowSchema);
 * ```
 */
export type FollowDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  FollowQueries
> &
  FollowMethods & {
    follower: UserDocument["_id"] | UserDocument
    following: UserDocument["_id"] | UserDocument
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of FriendRequestDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `FriendRequestDocument.toObject()`. To avoid conflicts with model names, use the type alias `FriendRequestObject`.
 * ```
 * const friendrequestObject = friendrequest.toObject();
 * ```
 */
export type FriendRequest = {
  sender: User["_id"] | User
  recipient: User["_id"] | User
  status?: "pending" | "accepted" | "declined" | "rejected"
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of FriendRequestDocument (type alias of `FriendRequest`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { FriendRequest } from "../models"
 * import { FriendRequestObject } from "../interfaces/mongoose.gen.ts"
 *
 * const friendrequestObject: FriendRequestObject = friendrequest.toObject();
 * ```
 */
export type FriendRequestObject = FriendRequest

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type FriendRequestQuery = mongoose.Query<
  any,
  FriendRequestDocument,
  FriendRequestQueries
> &
  FriendRequestQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `FriendRequestSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type FriendRequestQueries = {}

export type FriendRequestMethods = {}

export type FriendRequestStatics = {
  sendRequest: (this: FriendRequestModel, ...args: any[]) => any
  respondRequest: (this: FriendRequestModel, ...args: any[]) => any
  getRequestsForUser: (this: FriendRequestModel, ...args: any[]) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const FriendRequest = mongoose.model<FriendRequestDocument, FriendRequestModel>("FriendRequest", FriendRequestSchema);
 * ```
 */
export type FriendRequestModel = mongoose.Model<
  FriendRequestDocument,
  FriendRequestQueries
> &
  FriendRequestStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new FriendRequest schema instances:
 * ```
 * const FriendRequestSchema: FriendRequestSchema = new mongoose.Schema({ ... })
 * ```
 */
export type FriendRequestSchema = mongoose.Schema<
  FriendRequestDocument,
  FriendRequestModel,
  FriendRequestMethods,
  FriendRequestQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const FriendRequest = mongoose.model<FriendRequestDocument, FriendRequestModel>("FriendRequest", FriendRequestSchema);
 * ```
 */
export type FriendRequestDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  FriendRequestQueries
> &
  FriendRequestMethods & {
    sender: UserDocument["_id"] | UserDocument
    recipient: UserDocument["_id"] | UserDocument
    status?: "pending" | "accepted" | "declined" | "rejected"
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of FriendshipDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `FriendshipDocument.toObject()`. To avoid conflicts with model names, use the type alias `FriendshipObject`.
 * ```
 * const friendshipObject = friendship.toObject();
 * ```
 */
export type Friendship = {
  user1: User["_id"] | User
  user2: User["_id"] | User
  _id: mongoose.Types.ObjectId
  createdAt?: Date
}

/**
 * Lean version of FriendshipDocument (type alias of `Friendship`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Friendship } from "../models"
 * import { FriendshipObject } from "../interfaces/mongoose.gen.ts"
 *
 * const friendshipObject: FriendshipObject = friendship.toObject();
 * ```
 */
export type FriendshipObject = Friendship

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type FriendshipQuery = mongoose.Query<
  any,
  FriendshipDocument,
  FriendshipQueries
> &
  FriendshipQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `FriendshipSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type FriendshipQueries = {}

export type FriendshipMethods = {}

export type FriendshipStatics = {
  getFriends: (this: FriendshipModel, ...args: any[]) => any
  removeFriendship: (this: FriendshipModel, ...args: any[]) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Friendship = mongoose.model<FriendshipDocument, FriendshipModel>("Friendship", FriendshipSchema);
 * ```
 */
export type FriendshipModel = mongoose.Model<
  FriendshipDocument,
  FriendshipQueries
> &
  FriendshipStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Friendship schema instances:
 * ```
 * const FriendshipSchema: FriendshipSchema = new mongoose.Schema({ ... })
 * ```
 */
export type FriendshipSchema = mongoose.Schema<
  FriendshipDocument,
  FriendshipModel,
  FriendshipMethods,
  FriendshipQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Friendship = mongoose.model<FriendshipDocument, FriendshipModel>("Friendship", FriendshipSchema);
 * ```
 */
export type FriendshipDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  FriendshipQueries
> &
  FriendshipMethods & {
    user1: UserDocument["_id"] | UserDocument
    user2: UserDocument["_id"] | UserDocument
    _id: mongoose.Types.ObjectId
    createdAt?: Date
  }

/**
 * Lean version of GoalDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `GoalDocument.toObject()`. To avoid conflicts with model names, use the type alias `GoalObject`.
 * ```
 * const goalObject = goal.toObject();
 * ```
 */
export type Goal = {
  title: string
  description?: string
  status?: "not-started" | "in-progress" | "completed" | "archived"
  progress?: number
  completedAt?: Date
  milestones: (Milestone["_id"] | Milestone)[]
  visibility?: "public" | "private"
  user: User["_id"] | User
  category: string
  dueDate: Date
  tags: string[]
  priority?: "high" | "medium" | "low"
  reminders: (Reminder["_id"] | Reminder)[]
  isPinned?: boolean
  points?: number
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
  isActive: boolean
}

/**
 * Lean version of GoalDocument (type alias of `Goal`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Goal } from "../models"
 * import { GoalObject } from "../interfaces/mongoose.gen.ts"
 *
 * const goalObject: GoalObject = goal.toObject();
 * ```
 */
export type GoalObject = Goal

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type GoalQuery = mongoose.Query<any, GoalDocument, GoalQueries> &
  GoalQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `GoalSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type GoalQueries = {}

export type GoalMethods = {
  addReminder: (
    this: GoalDocument,
    message: string,
    remindAt: Date
  ) => Promise<any>
  markMilestoneComplete: (this: GoalDocument, index: number) => Promise<any>
}

export type GoalStatics = {
  findByUser: (
    this: GoalModel,
    userId: mongoose.Types.ObjectId,
    filter?: {}
  ) => any
  archiveCompleted: (this: GoalModel) => Promise<{ nDeleted: any }>
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Goal = mongoose.model<GoalDocument, GoalModel>("Goal", GoalSchema);
 * ```
 */
export type GoalModel = mongoose.Model<GoalDocument, GoalQueries> & GoalStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Goal schema instances:
 * ```
 * const GoalSchema: GoalSchema = new mongoose.Schema({ ... })
 * ```
 */
export type GoalSchema = mongoose.Schema<
  GoalDocument,
  GoalModel,
  GoalMethods,
  GoalQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Goal = mongoose.model<GoalDocument, GoalModel>("Goal", GoalSchema);
 * ```
 */
export type GoalDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  GoalQueries
> &
  GoalMethods & {
    title: string
    description?: string
    status?: "not-started" | "in-progress" | "completed" | "archived"
    progress?: number
    completedAt?: Date
    milestones: mongoose.Types.Array<
      MilestoneDocument["_id"] | MilestoneDocument
    >
    visibility?: "public" | "private"
    user: UserDocument["_id"] | UserDocument
    category: string
    dueDate: Date
    tags: mongoose.Types.Array<string>
    priority?: "high" | "medium" | "low"
    reminders: mongoose.Types.Array<ReminderDocument["_id"] | ReminderDocument>
    isPinned?: boolean
    points?: number
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
    isActive: boolean
  }

/**
 * Lean version of GoalMessageDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `GoalMessageDocument.toObject()`. To avoid conflicts with model names, use the type alias `GoalMessageObject`.
 * ```
 * const goalmessageObject = goalmessage.toObject();
 * ```
 */
export type GoalMessage = {
  goal: Goal["_id"] | Goal
  sender: User["_id"] | User
  message: string
  isDeleted?: boolean
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of GoalMessageDocument (type alias of `GoalMessage`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { GoalMessage } from "../models"
 * import { GoalMessageObject } from "../interfaces/mongoose.gen.ts"
 *
 * const goalmessageObject: GoalMessageObject = goalmessage.toObject();
 * ```
 */
export type GoalMessageObject = GoalMessage

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type GoalMessageQuery = mongoose.Query<
  any,
  GoalMessageDocument,
  GoalMessageQueries
> &
  GoalMessageQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `GoalMessageSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type GoalMessageQueries = {}

export type GoalMessageMethods = {
  softDelete: (this: GoalMessageDocument, ...args: any[]) => any
}

export type GoalMessageStatics = {
  getMessagesByGoal: (this: GoalMessageModel, ...args: any[]) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const GoalMessage = mongoose.model<GoalMessageDocument, GoalMessageModel>("GoalMessage", GoalMessageSchema);
 * ```
 */
export type GoalMessageModel = mongoose.Model<
  GoalMessageDocument,
  GoalMessageQueries
> &
  GoalMessageStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new GoalMessage schema instances:
 * ```
 * const GoalMessageSchema: GoalMessageSchema = new mongoose.Schema({ ... })
 * ```
 */
export type GoalMessageSchema = mongoose.Schema<
  GoalMessageDocument,
  GoalMessageModel,
  GoalMessageMethods,
  GoalMessageQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const GoalMessage = mongoose.model<GoalMessageDocument, GoalMessageModel>("GoalMessage", GoalMessageSchema);
 * ```
 */
export type GoalMessageDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  GoalMessageQueries
> &
  GoalMessageMethods & {
    goal: GoalDocument["_id"] | GoalDocument
    sender: UserDocument["_id"] | UserDocument
    message: string
    isDeleted?: boolean
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of GroupUnreadMessageDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `GroupDocument.toObject()`.
 * ```
 * const groupObject = group.toObject();
 * ```
 */
export type GroupUnreadMessage = {
  userId: User["_id"] | User
  count?: number
}

/**
 * Lean version of GroupDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `GroupDocument.toObject()`. To avoid conflicts with model names, use the type alias `GroupObject`.
 * ```
 * const groupObject = group.toObject();
 * ```
 */
export type Group = {
  name: string
  description?: string
  category:
    | "Fitness & Health"
    | "Learning & Education"
    | "Career & Business"
    | "Lifestyle & Hobbies"
    | "Creative & Arts"
    | "Technology"
  members: (User["_id"] | User)[]
  createdBy: User["_id"] | User
  visibility?: "public" | "private"
  isActive?: boolean
  lastActivity?: Date
  avatarKey?: string | null
  tags: string[]
  unreadMessages: GroupUnreadMessage[]
  typingUsers: (User["_id"] | User)[]
  isPinned?: boolean
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
  memberCount: number
  typingCount: number
}

/**
 * Lean version of GroupDocument (type alias of `Group`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Group } from "../models"
 * import { GroupObject } from "../interfaces/mongoose.gen.ts"
 *
 * const groupObject: GroupObject = group.toObject();
 * ```
 */
export type GroupObject = Group

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type GroupQuery = mongoose.Query<any, GroupDocument, GroupQueries> &
  GroupQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `GroupSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type GroupQueries = {}

export type GroupMethods = {
  addMember: (this: GroupDocument, userId: Types.ObjectId) => Promise<any>
  removeMember: (this: GroupDocument, userId: Types.ObjectId) => Promise<any>
  incrementUnread: (this: GroupDocument, userId: Types.ObjectId) => Promise<any>
  clearUnread: (this: GroupDocument, userId: Types.ObjectId) => Promise<any>
}

export type GroupStatics = {
  findPublicGroups: (this: GroupModel) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Group = mongoose.model<GroupDocument, GroupModel>("Group", GroupSchema);
 * ```
 */
export type GroupModel = mongoose.Model<GroupDocument, GroupQueries> &
  GroupStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Group schema instances:
 * ```
 * const GroupSchema: GroupSchema = new mongoose.Schema({ ... })
 * ```
 */
export type GroupSchema = mongoose.Schema<
  GroupDocument,
  GroupModel,
  GroupMethods,
  GroupQueries
>

/**
 * Mongoose Subdocument type
 *
 * Type of `GroupDocument["unreadMessages"]` element.
 */
export type GroupUnreadMessageDocument = mongoose.Types.Subdocument<any> & {
  userId: UserDocument["_id"] | UserDocument
  count?: number
}

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Group = mongoose.model<GroupDocument, GroupModel>("Group", GroupSchema);
 * ```
 */
export type GroupDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  GroupQueries
> &
  GroupMethods & {
    name: string
    description?: string
    category:
      | "Fitness & Health"
      | "Learning & Education"
      | "Career & Business"
      | "Lifestyle & Hobbies"
      | "Creative & Arts"
      | "Technology"
    members: mongoose.Types.Array<UserDocument["_id"] | UserDocument>
    createdBy: UserDocument["_id"] | UserDocument
    visibility?: "public" | "private"
    isActive?: boolean
    lastActivity?: Date
    avatarKey?: string | null
    tags: mongoose.Types.Array<string>
    unreadMessages: mongoose.Types.DocumentArray<GroupUnreadMessageDocument>
    typingUsers: mongoose.Types.Array<UserDocument["_id"] | UserDocument>
    isPinned?: boolean
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
    memberCount: number
    typingCount: number
  }

/**
 * Lean version of GroupInvitationDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `GroupInvitationDocument.toObject()`. To avoid conflicts with model names, use the type alias `GroupInvitationObject`.
 * ```
 * const groupinvitationObject = groupinvitation.toObject();
 * ```
 */
export type GroupInvitation = {
  groupId: Group["_id"] | Group
  sender: User["_id"] | User
  recipient: User["_id"] | User
  status?: "pending" | "accepted" | "rejected"
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of GroupInvitationDocument (type alias of `GroupInvitation`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { GroupInvitation } from "../models"
 * import { GroupInvitationObject } from "../interfaces/mongoose.gen.ts"
 *
 * const groupinvitationObject: GroupInvitationObject = groupinvitation.toObject();
 * ```
 */
export type GroupInvitationObject = GroupInvitation

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type GroupInvitationQuery = mongoose.Query<
  any,
  GroupInvitationDocument,
  GroupInvitationQueries
> &
  GroupInvitationQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `GroupInvitationSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type GroupInvitationQueries = {}

export type GroupInvitationMethods = {}

export type GroupInvitationStatics = {
  sendInvitation: (this: GroupInvitationModel, ...args: any[]) => any
  respondInvitation: (this: GroupInvitationModel, ...args: any[]) => any
  getPendingForUser: (this: GroupInvitationModel, ...args: any[]) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const GroupInvitation = mongoose.model<GroupInvitationDocument, GroupInvitationModel>("GroupInvitation", GroupInvitationSchema);
 * ```
 */
export type GroupInvitationModel = mongoose.Model<
  GroupInvitationDocument,
  GroupInvitationQueries
> &
  GroupInvitationStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new GroupInvitation schema instances:
 * ```
 * const GroupInvitationSchema: GroupInvitationSchema = new mongoose.Schema({ ... })
 * ```
 */
export type GroupInvitationSchema = mongoose.Schema<
  GroupInvitationDocument,
  GroupInvitationModel,
  GroupInvitationMethods,
  GroupInvitationQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const GroupInvitation = mongoose.model<GroupInvitationDocument, GroupInvitationModel>("GroupInvitation", GroupInvitationSchema);
 * ```
 */
export type GroupInvitationDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  GroupInvitationQueries
> &
  GroupInvitationMethods & {
    groupId: GroupDocument["_id"] | GroupDocument
    sender: UserDocument["_id"] | UserDocument
    recipient: UserDocument["_id"] | UserDocument
    status?: "pending" | "accepted" | "rejected"
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of GroupMessageDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `GroupMessageDocument.toObject()`. To avoid conflicts with model names, use the type alias `GroupMessageObject`.
 * ```
 * const groupmessageObject = groupmessage.toObject();
 * ```
 */
export type GroupMessage = {
  groupId: Group["_id"] | Group
  senderId: User["_id"] | User
  content: string
  timestamp?: Date
  type?: "message" | "system"
  editedAt?: Date | null
  deletedAt?: Date | null
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of GroupMessageDocument (type alias of `GroupMessage`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { GroupMessage } from "../models"
 * import { GroupMessageObject } from "../interfaces/mongoose.gen.ts"
 *
 * const groupmessageObject: GroupMessageObject = groupmessage.toObject();
 * ```
 */
export type GroupMessageObject = GroupMessage

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type GroupMessageQuery = mongoose.Query<
  any,
  GroupMessageDocument,
  GroupMessageQueries
> &
  GroupMessageQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `GroupMessageSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type GroupMessageQueries = {}

export type GroupMessageMethods = {}

export type GroupMessageStatics = {}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const GroupMessage = mongoose.model<GroupMessageDocument, GroupMessageModel>("GroupMessage", GroupMessageSchema);
 * ```
 */
export type GroupMessageModel = mongoose.Model<
  GroupMessageDocument,
  GroupMessageQueries
> &
  GroupMessageStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new GroupMessage schema instances:
 * ```
 * const GroupMessageSchema: GroupMessageSchema = new mongoose.Schema({ ... })
 * ```
 */
export type GroupMessageSchema = mongoose.Schema<
  GroupMessageDocument,
  GroupMessageModel,
  GroupMessageMethods,
  GroupMessageQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const GroupMessage = mongoose.model<GroupMessageDocument, GroupMessageModel>("GroupMessage", GroupMessageSchema);
 * ```
 */
export type GroupMessageDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  GroupMessageQueries
> &
  GroupMessageMethods & {
    groupId: GroupDocument["_id"] | GroupDocument
    senderId: UserDocument["_id"] | UserDocument
    content: string
    timestamp?: Date
    type?: "message" | "system"
    editedAt?: Date | null
    deletedAt?: Date | null
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
    formattedMessage: {
      id: string
      senderId: string
      senderName: string
      content: string
      timestamp: string
      type: "message" | "system"
    }
  }

/**
 * Lean version of HistoryDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `HistoryDocument.toObject()`. To avoid conflicts with model names, use the type alias `HistoryObject`.
 * ```
 * const historyObject = history.toObject();
 * ```
 */
export type History = {
  entity: string
  action: string
  details?: string
  user?: User["_id"] | User
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of HistoryDocument (type alias of `History`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { History } from "../models"
 * import { HistoryObject } from "../interfaces/mongoose.gen.ts"
 *
 * const historyObject: HistoryObject = history.toObject();
 * ```
 */
export type HistoryObject = History

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type HistoryQuery = mongoose.Query<
  any,
  HistoryDocument,
  HistoryQueries
> &
  HistoryQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `HistorySchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type HistoryQueries = {}

export type HistoryMethods = {
  toSummary: (this: HistoryDocument, ...args: any[]) => any
}

export type HistoryStatics = {
  record: (this: HistoryModel, ...args: any[]) => any
  getForEntity: (this: HistoryModel, ...args: any[]) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const History = mongoose.model<HistoryDocument, HistoryModel>("History", HistorySchema);
 * ```
 */
export type HistoryModel = mongoose.Model<HistoryDocument, HistoryQueries> &
  HistoryStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new History schema instances:
 * ```
 * const HistorySchema: HistorySchema = new mongoose.Schema({ ... })
 * ```
 */
export type HistorySchema = mongoose.Schema<
  HistoryDocument,
  HistoryModel,
  HistoryMethods,
  HistoryQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const History = mongoose.model<HistoryDocument, HistoryModel>("History", HistorySchema);
 * ```
 */
export type HistoryDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  HistoryQueries
> &
  HistoryMethods & {
    entity: string
    action: string
    details?: string
    user?: UserDocument["_id"] | UserDocument
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of IntegrationDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `IntegrationDocument.toObject()`. To avoid conflicts with model names, use the type alias `IntegrationObject`.
 * ```
 * const integrationObject = integration.toObject();
 * ```
 */
export type Integration = {
  user: User["_id"] | User
  type: "webhook" | "api" | "slack" | "google_calendar" | "github" | "custom"
  settings: any
  isActive?: boolean
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of IntegrationDocument (type alias of `Integration`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Integration } from "../models"
 * import { IntegrationObject } from "../interfaces/mongoose.gen.ts"
 *
 * const integrationObject: IntegrationObject = integration.toObject();
 * ```
 */
export type IntegrationObject = Integration

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type IntegrationQuery = mongoose.Query<
  any,
  IntegrationDocument,
  IntegrationQueries
> &
  IntegrationQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `IntegrationSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type IntegrationQueries = {}

export type IntegrationMethods = {
  toggleActiveState: (this: IntegrationDocument, ...args: any[]) => any
}

export type IntegrationStatics = {
  findActiveIntegrationsByUser: (this: IntegrationModel, ...args: any[]) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Integration = mongoose.model<IntegrationDocument, IntegrationModel>("Integration", IntegrationSchema);
 * ```
 */
export type IntegrationModel = mongoose.Model<
  IntegrationDocument,
  IntegrationQueries
> &
  IntegrationStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Integration schema instances:
 * ```
 * const IntegrationSchema: IntegrationSchema = new mongoose.Schema({ ... })
 * ```
 */
export type IntegrationSchema = mongoose.Schema<
  IntegrationDocument,
  IntegrationModel,
  IntegrationMethods,
  IntegrationQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Integration = mongoose.model<IntegrationDocument, IntegrationModel>("Integration", IntegrationSchema);
 * ```
 */
export type IntegrationDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  IntegrationQueries
> &
  IntegrationMethods & {
    user: UserDocument["_id"] | UserDocument
    type: "webhook" | "api" | "slack" | "google_calendar" | "github" | "custom"
    settings: any
    isActive?: boolean
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of InvitationDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `InvitationDocument.toObject()`. To avoid conflicts with model names, use the type alias `InvitationObject`.
 * ```
 * const invitationObject = invitation.toObject();
 * ```
 */
export type Invitation = {
  groupId: Group["_id"] | Group
  sender: User["_id"] | User
  recipient: User["_id"] | User
  status: "pending" | "accepted" | "rejected"
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of InvitationDocument (type alias of `Invitation`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Invitation } from "../models"
 * import { InvitationObject } from "../interfaces/mongoose.gen.ts"
 *
 * const invitationObject: InvitationObject = invitation.toObject();
 * ```
 */
export type InvitationObject = Invitation

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type InvitationQuery = mongoose.Query<
  any,
  InvitationDocument,
  InvitationQueries
> &
  InvitationQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `InvitationSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type InvitationQueries = {}

export type InvitationMethods = {}

export type InvitationStatics = {}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Invitation = mongoose.model<InvitationDocument, InvitationModel>("Invitation", InvitationSchema);
 * ```
 */
export type InvitationModel = mongoose.Model<
  InvitationDocument,
  InvitationQueries
> &
  InvitationStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Invitation schema instances:
 * ```
 * const InvitationSchema: InvitationSchema = new mongoose.Schema({ ... })
 * ```
 */
export type InvitationSchema = mongoose.Schema<
  InvitationDocument,
  InvitationModel,
  InvitationMethods,
  InvitationQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Invitation = mongoose.model<InvitationDocument, InvitationModel>("Invitation", InvitationSchema);
 * ```
 */
export type InvitationDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  InvitationQueries
> &
  InvitationMethods & {
    groupId: GroupDocument["_id"] | GroupDocument
    sender: UserDocument["_id"] | UserDocument
    recipient: UserDocument["_id"] | UserDocument
    status: "pending" | "accepted" | "rejected"
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of LevelDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `LevelDocument.toObject()`. To avoid conflicts with model names, use the type alias `LevelObject`.
 * ```
 * const levelObject = level.toObject();
 * ```
 */
export type Level = {
  user: User["_id"] | User
  points?: number
  level?: number
  nextLevelAt?: number
  rewards: (Reward["_id"] | Reward)[]
  lastActivity?: Date
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
  totalRewards: any
}

/**
 * Lean version of LevelDocument (type alias of `Level`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Level } from "../models"
 * import { LevelObject } from "../interfaces/mongoose.gen.ts"
 *
 * const levelObject: LevelObject = level.toObject();
 * ```
 */
export type LevelObject = Level

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type LevelQuery = mongoose.Query<any, LevelDocument, LevelQueries> &
  LevelQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `LevelSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type LevelQueries = {}

export type LevelMethods = {
  addPoints: (this: LevelDocument, amount: number) => Promise<any>
  addReward: (
    this: LevelDocument,
    rewardType: any,
    rewardValue: string
  ) => Promise<any>
}

export type LevelStatics = {
  getTopLevels: (this: LevelModel, limit: number) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Level = mongoose.model<LevelDocument, LevelModel>("Level", LevelSchema);
 * ```
 */
export type LevelModel = mongoose.Model<LevelDocument, LevelQueries> &
  LevelStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Level schema instances:
 * ```
 * const LevelSchema: LevelSchema = new mongoose.Schema({ ... })
 * ```
 */
export type LevelSchema = mongoose.Schema<
  LevelDocument,
  LevelModel,
  LevelMethods,
  LevelQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Level = mongoose.model<LevelDocument, LevelModel>("Level", LevelSchema);
 * ```
 */
export type LevelDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  LevelQueries
> &
  LevelMethods & {
    user: UserDocument["_id"] | UserDocument
    points?: number
    level?: number
    nextLevelAt?: number
    rewards: mongoose.Types.Array<RewardDocument["_id"] | RewardDocument>
    lastActivity?: Date
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
    totalRewards: any
  }

/**
 * Lean version of MatchDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `MatchDocument.toObject()`. To avoid conflicts with model names, use the type alias `MatchObject`.
 * ```
 * const matchObject = match.toObject();
 * ```
 */
export type Match = {
  user1: User["_id"] | User
  user2: User["_id"] | User
  status?: "pending" | "active" | "rejected" | "completed"
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of MatchDocument (type alias of `Match`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Match } from "../models"
 * import { MatchObject } from "../interfaces/mongoose.gen.ts"
 *
 * const matchObject: MatchObject = match.toObject();
 * ```
 */
export type MatchObject = Match

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type MatchQuery = mongoose.Query<any, MatchDocument, MatchQueries> &
  MatchQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `MatchSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type MatchQueries = {}

export type MatchMethods = {
  updateStatus: (this: MatchDocument, ...args: any[]) => any
}

export type MatchStatics = {
  findMatchesForUser: (this: MatchModel, ...args: any[]) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Match = mongoose.model<MatchDocument, MatchModel>("Match", MatchSchema);
 * ```
 */
export type MatchModel = mongoose.Model<MatchDocument, MatchQueries> &
  MatchStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Match schema instances:
 * ```
 * const MatchSchema: MatchSchema = new mongoose.Schema({ ... })
 * ```
 */
export type MatchSchema = mongoose.Schema<
  MatchDocument,
  MatchModel,
  MatchMethods,
  MatchQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Match = mongoose.model<MatchDocument, MatchModel>("Match", MatchSchema);
 * ```
 */
export type MatchDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  MatchQueries
> &
  MatchMethods & {
    user1: UserDocument["_id"] | UserDocument
    user2: UserDocument["_id"] | UserDocument
    status?: "pending" | "active" | "rejected" | "completed"
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of MessageReactionDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `MessageDocument.toObject()`.
 * ```
 * const messageObject = message.toObject();
 * ```
 */
export type MessageReaction = {
  userId: User["_id"] | User
  emoji: string
  reactedAt?: Date
}

/**
 * Lean version of MessageAttachmentDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `MessageDocument.toObject()`.
 * ```
 * const messageObject = message.toObject();
 * ```
 */
export type MessageAttachment = {
  url: string
  type: "image" | "video" | "file"
}

/**
 * Lean version of MessageDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `MessageDocument.toObject()`. To avoid conflicts with model names, use the type alias `MessageObject`.
 * ```
 * const messageObject = message.toObject();
 * ```
 */
export type Message = {
  chatId: Chat["_id"] | Chat
  senderId: User["_id"] | User
  receiverId?: User["_id"] | User
  text?: string
  messageType: "private" | "group"
  status?: "sent" | "delivered" | "seen" | "deleted" | "edited"
  reactions: MessageReaction[]
  attachments: MessageAttachment[]
  replyTo?: Message["_id"] | Message
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
  reactionCount: number
  attachmentCount: number
}

/**
 * Lean version of MessageDocument (type alias of `Message`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Message } from "../models"
 * import { MessageObject } from "../interfaces/mongoose.gen.ts"
 *
 * const messageObject: MessageObject = message.toObject();
 * ```
 */
export type MessageObject = Message

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type MessageQuery = mongoose.Query<
  any,
  MessageDocument,
  MessageQueries
> &
  MessageQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `MessageSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type MessageQueries = {}

export type MessageMethods = {
  addReaction: (
    this: MessageDocument,
    userId: Types.ObjectId,
    emoji: string
  ) => Promise<any>
  removeReaction: (
    this: MessageDocument,
    userId: Types.ObjectId
  ) => Promise<any>
  edit: (this: MessageDocument, newText: string) => Promise<any>
  softDelete: (this: MessageDocument) => Promise<any>
}

export type MessageStatics = {
  getByChat: (this: MessageModel, chatId: Types.ObjectId, limit?: number) => any
  getUserMessages: (
    this: MessageModel,
    userId: Types.ObjectId,
    limit?: number
  ) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Message = mongoose.model<MessageDocument, MessageModel>("Message", MessageSchema);
 * ```
 */
export type MessageModel = mongoose.Model<MessageDocument, MessageQueries> &
  MessageStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Message schema instances:
 * ```
 * const MessageSchema: MessageSchema = new mongoose.Schema({ ... })
 * ```
 */
export type MessageSchema = mongoose.Schema<
  MessageDocument,
  MessageModel,
  MessageMethods,
  MessageQueries
>

/**
 * Mongoose Subdocument type
 *
 * Type of `MessageDocument["reactions"]` element.
 */
export type MessageReactionDocument = mongoose.Types.Subdocument<any> & {
  userId: UserDocument["_id"] | UserDocument
  emoji: string
  reactedAt?: Date
}

/**
 * Mongoose Subdocument type
 *
 * Type of `MessageDocument["attachments"]` element.
 */
export type MessageAttachmentDocument = mongoose.Types.Subdocument<any> & {
  url: string
  type: "image" | "video" | "file"
}

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Message = mongoose.model<MessageDocument, MessageModel>("Message", MessageSchema);
 * ```
 */
export type MessageDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  MessageQueries
> &
  MessageMethods & {
    chatId: ChatDocument["_id"] | ChatDocument
    senderId: UserDocument["_id"] | UserDocument
    receiverId?: UserDocument["_id"] | UserDocument
    text?: string
    messageType: "private" | "group"
    status?: "sent" | "delivered" | "seen" | "deleted" | "edited"
    reactions: mongoose.Types.DocumentArray<MessageReactionDocument>
    attachments: mongoose.Types.DocumentArray<MessageAttachmentDocument>
    replyTo?: MessageDocument["_id"] | MessageDocument
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
    reactionCount: number
    attachmentCount: number
  }

/**
 * Lean version of MessageReactionDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `MessageReactionDocument.toObject()`. To avoid conflicts with model names, use the type alias `MessageReactionObject`.
 * ```
 * const messagereactionObject = messagereaction.toObject();
 * ```
 */
export type MessageReaction = {
  messageId: Message["_id"] | Message
  userId: User["_id"] | User
  reaction: "like" | "love" | "haha" | "sad" | "angry" | "wow"
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of MessageReactionDocument (type alias of `MessageReaction`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { MessageReaction } from "../models"
 * import { MessageReactionObject } from "../interfaces/mongoose.gen.ts"
 *
 * const messagereactionObject: MessageReactionObject = messagereaction.toObject();
 * ```
 */
export type MessageReactionObject = MessageReaction

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type MessageReactionQuery = mongoose.Query<
  any,
  MessageReactionDocument,
  MessageReactionQueries
> &
  MessageReactionQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `MessageReactionSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type MessageReactionQueries = {}

export type MessageReactionMethods = {}

export type MessageReactionStatics = {
  addReaction: (this: MessageReactionModel, ...args: any[]) => any
  removeReaction: (this: MessageReactionModel, ...args: any[]) => any
  getReactionsForMessage: (this: MessageReactionModel, ...args: any[]) => any
  countReactions: (this: MessageReactionModel, ...args: any[]) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const MessageReaction = mongoose.model<MessageReactionDocument, MessageReactionModel>("MessageReaction", MessageReactionSchema);
 * ```
 */
export type MessageReactionModel = mongoose.Model<
  MessageReactionDocument,
  MessageReactionQueries
> &
  MessageReactionStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new MessageReaction schema instances:
 * ```
 * const MessageReactionSchema: MessageReactionSchema = new mongoose.Schema({ ... })
 * ```
 */
export type MessageReactionSchema = mongoose.Schema<
  MessageReactionDocument,
  MessageReactionModel,
  MessageReactionMethods,
  MessageReactionQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const MessageReaction = mongoose.model<MessageReactionDocument, MessageReactionModel>("MessageReaction", MessageReactionSchema);
 * ```
 */
export type MessageReactionDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  MessageReactionQueries
> &
  MessageReactionMethods & {
    messageId: MessageDocument["_id"] | MessageDocument
    userId: UserDocument["_id"] | UserDocument
    reaction: "like" | "love" | "haha" | "sad" | "angry" | "wow"
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of MilestoneDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `MilestoneDocument.toObject()`. To avoid conflicts with model names, use the type alias `MilestoneObject`.
 * ```
 * const milestoneObject = milestone.toObject();
 * ```
 */
export type Milestone = {
  title: string
  description: string
  dueDate: Date
  completed?: boolean
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of MilestoneDocument (type alias of `Milestone`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Milestone } from "../models"
 * import { MilestoneObject } from "../interfaces/mongoose.gen.ts"
 *
 * const milestoneObject: MilestoneObject = milestone.toObject();
 * ```
 */
export type MilestoneObject = Milestone

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type MilestoneQuery = mongoose.Query<
  any,
  MilestoneDocument,
  MilestoneQueries
> &
  MilestoneQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `MilestoneSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type MilestoneQueries = {}

export type MilestoneMethods = {
  isPastDue: (this: MilestoneDocument) => boolean
}

export type MilestoneStatics = {
  findUpcoming: (this: MilestoneModel, daysAhead?: number) => any
  findOverdue: (this: MilestoneModel) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Milestone = mongoose.model<MilestoneDocument, MilestoneModel>("Milestone", MilestoneSchema);
 * ```
 */
export type MilestoneModel = mongoose.Model<
  MilestoneDocument,
  MilestoneQueries
> &
  MilestoneStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Milestone schema instances:
 * ```
 * const MilestoneSchema: MilestoneSchema = new mongoose.Schema({ ... })
 * ```
 */
export type MilestoneSchema = mongoose.Schema<
  MilestoneDocument,
  MilestoneModel,
  MilestoneMethods,
  MilestoneQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Milestone = mongoose.model<MilestoneDocument, MilestoneModel>("Milestone", MilestoneSchema);
 * ```
 */
export type MilestoneDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  MilestoneQueries
> &
  MilestoneMethods & {
    title: string
    description: string
    dueDate: Date
    completed?: boolean
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of MilitaryMessageDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `MilitaryMessageDocument.toObject()`. To avoid conflicts with model names, use the type alias `MilitaryMessageObject`.
 * ```
 * const militarymessageObject = militarymessage.toObject();
 * ```
 */
export type MilitaryMessage = {
  chatroom: MilitarySupportChatroom["_id"] | MilitarySupportChatroom
  user: User["_id"] | User
  text: string
  timestamp?: Date
  isDeleted?: boolean
  attachments: string[]
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
  attachmentCount: number
}

/**
 * Lean version of MilitaryMessageDocument (type alias of `MilitaryMessage`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { MilitaryMessage } from "../models"
 * import { MilitaryMessageObject } from "../interfaces/mongoose.gen.ts"
 *
 * const militarymessageObject: MilitaryMessageObject = militarymessage.toObject();
 * ```
 */
export type MilitaryMessageObject = MilitaryMessage

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type MilitaryMessageQuery = mongoose.Query<
  any,
  MilitaryMessageDocument,
  MilitaryMessageQueries
> &
  MilitaryMessageQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `MilitaryMessageSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type MilitaryMessageQueries = {}

export type MilitaryMessageMethods = {
  softDelete: (this: MilitaryMessageDocument, ...args: any[]) => any
  addAttachment: (this: MilitaryMessageDocument, ...args: any[]) => any
}

export type MilitaryMessageStatics = {
  getByChatroom: (this: MilitaryMessageModel, ...args: any[]) => any
  searchText: (this: MilitaryMessageModel, ...args: any[]) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const MilitaryMessage = mongoose.model<MilitaryMessageDocument, MilitaryMessageModel>("MilitaryMessage", MilitaryMessageSchema);
 * ```
 */
export type MilitaryMessageModel = mongoose.Model<
  MilitaryMessageDocument,
  MilitaryMessageQueries
> &
  MilitaryMessageStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new MilitaryMessage schema instances:
 * ```
 * const MilitaryMessageSchema: MilitaryMessageSchema = new mongoose.Schema({ ... })
 * ```
 */
export type MilitaryMessageSchema = mongoose.Schema<
  MilitaryMessageDocument,
  MilitaryMessageModel,
  MilitaryMessageMethods,
  MilitaryMessageQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const MilitaryMessage = mongoose.model<MilitaryMessageDocument, MilitaryMessageModel>("MilitaryMessage", MilitaryMessageSchema);
 * ```
 */
export type MilitaryMessageDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  MilitaryMessageQueries
> &
  MilitaryMessageMethods & {
    chatroom:
      | MilitarySupportChatroomDocument["_id"]
      | MilitarySupportChatroomDocument
    user: UserDocument["_id"] | UserDocument
    text: string
    timestamp?: Date
    isDeleted?: boolean
    attachments: mongoose.Types.Array<string>
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
    attachmentCount: number
  }

/**
 * Lean version of ExternalSupportResourceDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `ExternalSupportResourceDocument.toObject()`. To avoid conflicts with model names, use the type alias `ExternalSupportResourceObject`.
 * ```
 * const externalsupportresourceObject = externalsupportresource.toObject();
 * ```
 */
export type ExternalSupportResource = {
  title: string
  url: string
  description?: string
  category?: "hotline" | "website" | "forum" | "organization" | "other"
  isActive?: boolean
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
  domain: string
}

/**
 * Lean version of ExternalSupportResourceDocument (type alias of `ExternalSupportResource`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { ExternalSupportResource } from "../models"
 * import { ExternalSupportResourceObject } from "../interfaces/mongoose.gen.ts"
 *
 * const externalsupportresourceObject: ExternalSupportResourceObject = externalsupportresource.toObject();
 * ```
 */
export type ExternalSupportResourceObject = ExternalSupportResource

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type ExternalSupportResourceQuery = mongoose.Query<
  any,
  ExternalSupportResourceDocument,
  ExternalSupportResourceQueries
> &
  ExternalSupportResourceQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `ExternalSupportResourceSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type ExternalSupportResourceQueries = {}

export type ExternalSupportResourceMethods = {
  deactivate: (this: ExternalSupportResourceDocument, ...args: any[]) => any
  activate: (this: ExternalSupportResourceDocument, ...args: any[]) => any
}

export type ExternalSupportResourceStatics = {
  findByCategory: (this: ExternalSupportResourceModel, ...args: any[]) => any
  searchByTitle: (this: ExternalSupportResourceModel, ...args: any[]) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const ExternalSupportResource = mongoose.model<ExternalSupportResourceDocument, ExternalSupportResourceModel>("ExternalSupportResource", ExternalSupportResourceSchema);
 * ```
 */
export type ExternalSupportResourceModel = mongoose.Model<
  ExternalSupportResourceDocument,
  ExternalSupportResourceQueries
> &
  ExternalSupportResourceStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new ExternalSupportResource schema instances:
 * ```
 * const ExternalSupportResourceSchema: ExternalSupportResourceSchema = new mongoose.Schema({ ... })
 * ```
 */
export type ExternalSupportResourceSchema = mongoose.Schema<
  ExternalSupportResourceDocument,
  ExternalSupportResourceModel,
  ExternalSupportResourceMethods,
  ExternalSupportResourceQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const ExternalSupportResource = mongoose.model<ExternalSupportResourceDocument, ExternalSupportResourceModel>("ExternalSupportResource", ExternalSupportResourceSchema);
 * ```
 */
export type ExternalSupportResourceDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  ExternalSupportResourceQueries
> &
  ExternalSupportResourceMethods & {
    title: string
    url: string
    description?: string
    category?: "hotline" | "website" | "forum" | "organization" | "other"
    isActive?: boolean
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
    domain: string
  }

/**
 * Lean version of MilitaryUserMessageDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `MilitaryUserDocument.toObject()`.
 * ```
 * const militaryuserObject = militaryuser.toObject();
 * ```
 */
export type MilitaryUserMessage = {
  sender: User["_id"] | User
  content: string
  timestamp?: Date
  _id: mongoose.Types.ObjectId
}

/**
 * Lean version of MilitaryUserDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `MilitaryUserDocument.toObject()`. To avoid conflicts with model names, use the type alias `MilitaryUserObject`.
 * ```
 * const militaryuserObject = militaryuser.toObject();
 * ```
 */
export type MilitaryUser = {
  userId: User["_id"] | User
  isMilitary?: boolean
  messages: MilitaryUserMessage[]
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
  messageCount: number
}

/**
 * Lean version of MilitaryUserDocument (type alias of `MilitaryUser`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { MilitaryUser } from "../models"
 * import { MilitaryUserObject } from "../interfaces/mongoose.gen.ts"
 *
 * const militaryuserObject: MilitaryUserObject = militaryuser.toObject();
 * ```
 */
export type MilitaryUserObject = MilitaryUser

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type MilitaryUserQuery = mongoose.Query<
  any,
  MilitaryUserDocument,
  MilitaryUserQueries
> &
  MilitaryUserQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `MilitaryUserSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type MilitaryUserQueries = {}

export type MilitaryUserMethods = {
  addMessage: (this: MilitaryUserDocument, ...args: any[]) => any
  removeMessage: (this: MilitaryUserDocument, ...args: any[]) => any
}

export type MilitaryUserStatics = {
  findByUser: (this: MilitaryUserModel, ...args: any[]) => any
  getMilitaryUsers: (this: MilitaryUserModel, ...args: any[]) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const MilitaryUser = mongoose.model<MilitaryUserDocument, MilitaryUserModel>("MilitaryUser", MilitaryUserSchema);
 * ```
 */
export type MilitaryUserModel = mongoose.Model<
  MilitaryUserDocument,
  MilitaryUserQueries
> &
  MilitaryUserStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new MilitaryUser schema instances:
 * ```
 * const MilitaryUserSchema: MilitaryUserSchema = new mongoose.Schema({ ... })
 * ```
 */
export type MilitaryUserSchema = mongoose.Schema<
  MilitaryUserDocument,
  MilitaryUserModel,
  MilitaryUserMethods,
  MilitaryUserQueries
>

/**
 * Mongoose Subdocument type
 *
 * Type of `MilitaryUserDocument["messages"]` element.
 */
export type MilitaryUserMessageDocument =
  mongoose.Types.Subdocument<mongoose.Types.ObjectId> & {
    sender: UserDocument["_id"] | UserDocument
    content: string
    timestamp?: Date
    _id: mongoose.Types.ObjectId
  }

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const MilitaryUser = mongoose.model<MilitaryUserDocument, MilitaryUserModel>("MilitaryUser", MilitaryUserSchema);
 * ```
 */
export type MilitaryUserDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  MilitaryUserQueries
> &
  MilitaryUserMethods & {
    userId: UserDocument["_id"] | UserDocument
    isMilitary?: boolean
    messages: mongoose.Types.DocumentArray<MilitaryUserMessageDocument>
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
    messageCount: number
  }

/**
 * Lean version of MilitarySupportChatroomDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `MilitarySupportChatroomDocument.toObject()`. To avoid conflicts with model names, use the type alias `MilitarySupportChatroomObject`.
 * ```
 * const militarysupportchatroomObject = militarysupportchatroom.toObject();
 * ```
 */
export type MilitarySupportChatroom = {
  name: string
  description?: string
  members: (User["_id"] | User)[]
  visibility?: "public" | "private"
  isActive?: boolean
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
  memberCount: number
}

/**
 * Lean version of MilitarySupportChatroomDocument (type alias of `MilitarySupportChatroom`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { MilitarySupportChatroom } from "../models"
 * import { MilitarySupportChatroomObject } from "../interfaces/mongoose.gen.ts"
 *
 * const militarysupportchatroomObject: MilitarySupportChatroomObject = militarysupportchatroom.toObject();
 * ```
 */
export type MilitarySupportChatroomObject = MilitarySupportChatroom

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type MilitarySupportChatroomQuery = mongoose.Query<
  any,
  MilitarySupportChatroomDocument,
  MilitarySupportChatroomQueries
> &
  MilitarySupportChatroomQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `MilitarySupportChatroomSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type MilitarySupportChatroomQueries = {}

export type MilitarySupportChatroomMethods = {
  addMember: (this: MilitarySupportChatroomDocument, ...args: any[]) => any
  removeMember: (this: MilitarySupportChatroomDocument, ...args: any[]) => any
  deactivate: (this: MilitarySupportChatroomDocument, ...args: any[]) => any
  activate: (this: MilitarySupportChatroomDocument, ...args: any[]) => any
}

export type MilitarySupportChatroomStatics = {
  findPublic: (this: MilitarySupportChatroomModel, ...args: any[]) => any
  findByMember: (this: MilitarySupportChatroomModel, ...args: any[]) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const MilitarySupportChatroom = mongoose.model<MilitarySupportChatroomDocument, MilitarySupportChatroomModel>("MilitarySupportChatroom", MilitarySupportChatroomSchema);
 * ```
 */
export type MilitarySupportChatroomModel = mongoose.Model<
  MilitarySupportChatroomDocument,
  MilitarySupportChatroomQueries
> &
  MilitarySupportChatroomStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new MilitarySupportChatroom schema instances:
 * ```
 * const MilitarySupportChatroomSchema: MilitarySupportChatroomSchema = new mongoose.Schema({ ... })
 * ```
 */
export type MilitarySupportChatroomSchema = mongoose.Schema<
  MilitarySupportChatroomDocument,
  MilitarySupportChatroomModel,
  MilitarySupportChatroomMethods,
  MilitarySupportChatroomQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const MilitarySupportChatroom = mongoose.model<MilitarySupportChatroomDocument, MilitarySupportChatroomModel>("MilitarySupportChatroom", MilitarySupportChatroomSchema);
 * ```
 */
export type MilitarySupportChatroomDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  MilitarySupportChatroomQueries
> &
  MilitarySupportChatroomMethods & {
    name: string
    description?: string
    members: mongoose.Types.Array<UserDocument["_id"] | UserDocument>
    visibility?: "public" | "private"
    isActive?: boolean
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
    memberCount: number
  }

/**
 * Lean version of NewsletterDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `NewsletterDocument.toObject()`. To avoid conflicts with model names, use the type alias `NewsletterObject`.
 * ```
 * const newsletterObject = newsletter.toObject();
 * ```
 */
export type Newsletter = {
  email: string
  subscribedAt?: Date
  status?: "subscribed" | "unsubscribed"
  unsubscribeToken: string
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of NewsletterDocument (type alias of `Newsletter`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Newsletter } from "../models"
 * import { NewsletterObject } from "../interfaces/mongoose.gen.ts"
 *
 * const newsletterObject: NewsletterObject = newsletter.toObject();
 * ```
 */
export type NewsletterObject = Newsletter

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type NewsletterQuery = mongoose.Query<
  any,
  NewsletterDocument,
  NewsletterQueries
> &
  NewsletterQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `NewsletterSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type NewsletterQueries = {}

export type NewsletterMethods = {
  unsubscribe: (this: NewsletterDocument, ...args: any[]) => any
  regenerateUnsubscribeToken: (this: NewsletterDocument, ...args: any[]) => any
}

export type NewsletterStatics = {
  findOrCreate: (this: NewsletterModel, ...args: any[]) => any
  findSubscribed: (this: NewsletterModel, ...args: any[]) => any
  findUnsubscribed: (this: NewsletterModel, ...args: any[]) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Newsletter = mongoose.model<NewsletterDocument, NewsletterModel>("Newsletter", NewsletterSchema);
 * ```
 */
export type NewsletterModel = mongoose.Model<
  NewsletterDocument,
  NewsletterQueries
> &
  NewsletterStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Newsletter schema instances:
 * ```
 * const NewsletterSchema: NewsletterSchema = new mongoose.Schema({ ... })
 * ```
 */
export type NewsletterSchema = mongoose.Schema<
  NewsletterDocument,
  NewsletterModel,
  NewsletterMethods,
  NewsletterQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Newsletter = mongoose.model<NewsletterDocument, NewsletterModel>("Newsletter", NewsletterSchema);
 * ```
 */
export type NewsletterDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  NewsletterQueries
> &
  NewsletterMethods & {
    email: string
    subscribedAt?: Date
    status?: "subscribed" | "unsubscribed"
    unsubscribeToken: string
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of NotificationDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `NotificationDocument.toObject()`. To avoid conflicts with model names, use the type alias `NotificationObject`.
 * ```
 * const notificationObject = notification.toObject();
 * ```
 */
export type Notification = {
  user: User["_id"] | User
  sender?: User["_id"] | User | null
  message: string
  type:
    | "friend_request"
    | "message"
    | "group_invite"
    | "blog_activity"
    | "goal_milestone"
  read?: boolean
  link?: string
  expiresAt?: Date
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
  isExpired: boolean
}

/**
 * Lean version of NotificationDocument (type alias of `Notification`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Notification } from "../models"
 * import { NotificationObject } from "../interfaces/mongoose.gen.ts"
 *
 * const notificationObject: NotificationObject = notification.toObject();
 * ```
 */
export type NotificationObject = Notification

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type NotificationQuery = mongoose.Query<
  any,
  NotificationDocument,
  NotificationQueries
> &
  NotificationQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `NotificationSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type NotificationQueries = {}

export type NotificationMethods = {
  markRead: (this: NotificationDocument, ...args: any[]) => any
  markUnread: (this: NotificationDocument, ...args: any[]) => any
}

export type NotificationStatics = {
  findByUser: (this: NotificationModel, ...args: any[]) => any
  markAllRead: (this: NotificationModel, ...args: any[]) => any
  createNotification: (this: NotificationModel, ...args: any[]) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Notification = mongoose.model<NotificationDocument, NotificationModel>("Notification", NotificationSchema);
 * ```
 */
export type NotificationModel = mongoose.Model<
  NotificationDocument,
  NotificationQueries
> &
  NotificationStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Notification schema instances:
 * ```
 * const NotificationSchema: NotificationSchema = new mongoose.Schema({ ... })
 * ```
 */
export type NotificationSchema = mongoose.Schema<
  NotificationDocument,
  NotificationModel,
  NotificationMethods,
  NotificationQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Notification = mongoose.model<NotificationDocument, NotificationModel>("Notification", NotificationSchema);
 * ```
 */
export type NotificationDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  NotificationQueries
> &
  NotificationMethods & {
    user: UserDocument["_id"] | UserDocument
    sender?: UserDocument["_id"] | UserDocument | null
    message: string
    type:
      | "friend_request"
      | "message"
      | "group_invite"
      | "blog_activity"
      | "goal_milestone"
    read?: boolean
    link?: string
    expiresAt?: Date
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
    isExpired: boolean
  }

/**
 * Lean version of PaymentDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `PaymentDocument.toObject()`. To avoid conflicts with model names, use the type alias `PaymentObject`.
 * ```
 * const paymentObject = payment.toObject();
 * ```
 */
export type Payment = {
  userId: User["_id"] | User
  paymentId: string
  amount: number
  currency: string
  status?: "pending" | "completed" | "failed" | "refunded"
  method: "card" | "paypal" | "bank_transfer"
  description?: string
  receiptUrl?: string
  paymentDate?: Date
  expiresAt?: Date
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
  isExpired: boolean
}

/**
 * Lean version of PaymentDocument (type alias of `Payment`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Payment } from "../models"
 * import { PaymentObject } from "../interfaces/mongoose.gen.ts"
 *
 * const paymentObject: PaymentObject = payment.toObject();
 * ```
 */
export type PaymentObject = Payment

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type PaymentQuery = mongoose.Query<
  any,
  PaymentDocument,
  PaymentQueries
> &
  PaymentQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `PaymentSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type PaymentQueries = {}

export type PaymentMethods = {
  markAsCompleted: (this: PaymentDocument, ...args: any[]) => any
  markAsFailed: (this: PaymentDocument, ...args: any[]) => any
}

export type PaymentStatics = {
  findByUser: (this: PaymentModel, ...args: any[]) => any
  getTotalPaymentsForUser: (this: PaymentModel, ...args: any[]) => any
  refundPayment: (this: PaymentModel, ...args: any[]) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Payment = mongoose.model<PaymentDocument, PaymentModel>("Payment", PaymentSchema);
 * ```
 */
export type PaymentModel = mongoose.Model<PaymentDocument, PaymentQueries> &
  PaymentStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Payment schema instances:
 * ```
 * const PaymentSchema: PaymentSchema = new mongoose.Schema({ ... })
 * ```
 */
export type PaymentSchema = mongoose.Schema<
  PaymentDocument,
  PaymentModel,
  PaymentMethods,
  PaymentQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Payment = mongoose.model<PaymentDocument, PaymentModel>("Payment", PaymentSchema);
 * ```
 */
export type PaymentDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  PaymentQueries
> &
  PaymentMethods & {
    userId: UserDocument["_id"] | UserDocument
    paymentId: string
    amount: number
    currency: string
    status?: "pending" | "completed" | "failed" | "refunded"
    method: "card" | "paypal" | "bank_transfer"
    description?: string
    receiptUrl?: string
    paymentDate?: Date
    expiresAt?: Date
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
    isExpired: boolean
  }

/**
 * Lean version of PaymentTransactionDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `PaymentTransactionDocument.toObject()`. To avoid conflicts with model names, use the type alias `PaymentTransactionObject`.
 * ```
 * const paymenttransactionObject = paymenttransaction.toObject();
 * ```
 */
export type PaymentTransaction = {
  userId: User["_id"] | User
  transactionId: string
  paymentMethod: "card" | "paypal" | "bank_transfer" | "crypto"
  amount: number
  currency: string
  status?: "initiated" | "processing" | "completed" | "failed" | "refunded"
  description?: string
  initiatedAt?: Date
  completedAt?: Date
  paymentGatewayResponse?: any | null
  isRefundable?: boolean
  refundReason?: string
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
  isCompleted: boolean
}

/**
 * Lean version of PaymentTransactionDocument (type alias of `PaymentTransaction`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { PaymentTransaction } from "../models"
 * import { PaymentTransactionObject } from "../interfaces/mongoose.gen.ts"
 *
 * const paymenttransactionObject: PaymentTransactionObject = paymenttransaction.toObject();
 * ```
 */
export type PaymentTransactionObject = PaymentTransaction

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type PaymentTransactionQuery = mongoose.Query<
  any,
  PaymentTransactionDocument,
  PaymentTransactionQueries
> &
  PaymentTransactionQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `PaymentTransactionSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type PaymentTransactionQueries = {}

export type PaymentTransactionMethods = {
  markAsCompleted: (this: PaymentTransactionDocument, ...args: any[]) => any
  markAsFailed: (this: PaymentTransactionDocument, ...args: any[]) => any
  initiateRefund: (this: PaymentTransactionDocument, ...args: any[]) => any
}

export type PaymentTransactionStatics = {
  findByUser: (this: PaymentTransactionModel, ...args: any[]) => any
  getTotalAmountForUser: (this: PaymentTransactionModel, ...args: any[]) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const PaymentTransaction = mongoose.model<PaymentTransactionDocument, PaymentTransactionModel>("PaymentTransaction", PaymentTransactionSchema);
 * ```
 */
export type PaymentTransactionModel = mongoose.Model<
  PaymentTransactionDocument,
  PaymentTransactionQueries
> &
  PaymentTransactionStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new PaymentTransaction schema instances:
 * ```
 * const PaymentTransactionSchema: PaymentTransactionSchema = new mongoose.Schema({ ... })
 * ```
 */
export type PaymentTransactionSchema = mongoose.Schema<
  PaymentTransactionDocument,
  PaymentTransactionModel,
  PaymentTransactionMethods,
  PaymentTransactionQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const PaymentTransaction = mongoose.model<PaymentTransactionDocument, PaymentTransactionModel>("PaymentTransaction", PaymentTransactionSchema);
 * ```
 */
export type PaymentTransactionDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  PaymentTransactionQueries
> &
  PaymentTransactionMethods & {
    userId: UserDocument["_id"] | UserDocument
    transactionId: string
    paymentMethod: "card" | "paypal" | "bank_transfer" | "crypto"
    amount: number
    currency: string
    status?: "initiated" | "processing" | "completed" | "failed" | "refunded"
    description?: string
    initiatedAt?: Date
    completedAt?: Date
    paymentGatewayResponse?: any | null
    isRefundable?: boolean
    refundReason?: string
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
    isCompleted: boolean
  }

/**
 * Lean version of PointRedemptionDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `PointDocument.toObject()`.
 * ```
 * const pointObject = point.toObject();
 * ```
 */
export type PointRedemption = {
  reward: string
  pointsSpent: number
  redemptionDate?: Date
  _id: mongoose.Types.ObjectId
}

/**
 * Lean version of PointDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `PointDocument.toObject()`. To avoid conflicts with model names, use the type alias `PointObject`.
 * ```
 * const pointObject = point.toObject();
 * ```
 */
export type Point = {
  user: User["_id"] | User
  points?: number
  redemptions: PointRedemption[]
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of PointDocument (type alias of `Point`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Point } from "../models"
 * import { PointObject } from "../interfaces/mongoose.gen.ts"
 *
 * const pointObject: PointObject = point.toObject();
 * ```
 */
export type PointObject = Point

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type PointQuery = mongoose.Query<any, PointDocument, PointQueries> &
  PointQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `PointSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type PointQueries = {}

export type PointMethods = {
  addPoints: (this: PointDocument, ...args: any[]) => any
  subtractPoints: (this: PointDocument, ...args: any[]) => any
  recordRedemption: (this: PointDocument, ...args: any[]) => any
}

export type PointStatics = {
  findByUser: (this: PointModel, ...args: any[]) => any
  getTotalPoints: (this: PointModel, ...args: any[]) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Point = mongoose.model<PointDocument, PointModel>("Point", PointSchema);
 * ```
 */
export type PointModel = mongoose.Model<PointDocument, PointQueries> &
  PointStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Point schema instances:
 * ```
 * const PointSchema: PointSchema = new mongoose.Schema({ ... })
 * ```
 */
export type PointSchema = mongoose.Schema<
  PointDocument,
  PointModel,
  PointMethods,
  PointQueries
>

/**
 * Mongoose Subdocument type
 *
 * Type of `PointDocument["redemptions"]` element.
 */
export type PointRedemptionDocument =
  mongoose.Types.Subdocument<mongoose.Types.ObjectId> & {
    reward: string
    pointsSpent: number
    redemptionDate?: Date
    _id: mongoose.Types.ObjectId
  }

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Point = mongoose.model<PointDocument, PointModel>("Point", PointSchema);
 * ```
 */
export type PointDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  PointQueries
> &
  PointMethods & {
    user: UserDocument["_id"] | UserDocument
    points?: number
    redemptions: mongoose.Types.DocumentArray<PointRedemptionDocument>
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of PollOptionDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `PollDocument.toObject()`.
 * ```
 * const pollObject = poll.toObject();
 * ```
 */
export type PollOption = {
  option: string
  votes: (User["_id"] | User)[]
  _id: mongoose.Types.ObjectId
}

/**
 * Lean version of PollDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `PollDocument.toObject()`. To avoid conflicts with model names, use the type alias `PollObject`.
 * ```
 * const pollObject = poll.toObject();
 * ```
 */
export type Poll = {
  groupId: Group["_id"] | Group
  question: string
  options: PollOption[]
  expirationDate: Date
  status?: "active" | "expired"
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
  isExpired: boolean
  totalVotes: number
}

/**
 * Lean version of PollDocument (type alias of `Poll`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Poll } from "../models"
 * import { PollObject } from "../interfaces/mongoose.gen.ts"
 *
 * const pollObject: PollObject = poll.toObject();
 * ```
 */
export type PollObject = Poll

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type PollQuery = mongoose.Query<any, PollDocument, PollQueries> &
  PollQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `PollSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type PollQueries = {}

export type PollMethods = {
  vote: (this: PollDocument, ...args: any[]) => any
  close: (this: PollDocument, ...args: any[]) => any
}

export type PollStatics = {
  getActive: (this: PollModel, ...args: any[]) => any
  getExpired: (this: PollModel, ...args: any[]) => any
  getByGroup: (this: PollModel, ...args: any[]) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Poll = mongoose.model<PollDocument, PollModel>("Poll", PollSchema);
 * ```
 */
export type PollModel = mongoose.Model<PollDocument, PollQueries> & PollStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Poll schema instances:
 * ```
 * const PollSchema: PollSchema = new mongoose.Schema({ ... })
 * ```
 */
export type PollSchema = mongoose.Schema<
  PollDocument,
  PollModel,
  PollMethods,
  PollQueries
>

/**
 * Mongoose Subdocument type
 *
 * Type of `PollDocument["options"]` element.
 */
export type PollOptionDocument =
  mongoose.Types.Subdocument<mongoose.Types.ObjectId> & {
    option: string
    votes: mongoose.Types.Array<UserDocument["_id"] | UserDocument>
    _id: mongoose.Types.ObjectId
  }

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Poll = mongoose.model<PollDocument, PollModel>("Poll", PollSchema);
 * ```
 */
export type PollDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  PollQueries
> &
  PollMethods & {
    groupId: GroupDocument["_id"] | GroupDocument
    question: string
    options: mongoose.Types.DocumentArray<PollOptionDocument>
    expirationDate: Date
    status?: "active" | "expired"
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
    isExpired: boolean
    totalVotes: number
  }

/**
 * Lean version of PollResultDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `PollResultDocument.toObject()`. To avoid conflicts with model names, use the type alias `PollResultObject`.
 * ```
 * const pollresultObject = pollresult.toObject();
 * ```
 */
export type PollResult = {
  pollId: Poll["_id"] | Poll
  optionId: Poll["_id"] | Poll
  votesCount?: number
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of PollResultDocument (type alias of `PollResult`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { PollResult } from "../models"
 * import { PollResultObject } from "../interfaces/mongoose.gen.ts"
 *
 * const pollresultObject: PollResultObject = pollresult.toObject();
 * ```
 */
export type PollResultObject = PollResult

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type PollResultQuery = mongoose.Query<
  any,
  PollResultDocument,
  PollResultQueries
> &
  PollResultQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `PollResultSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type PollResultQueries = {}

export type PollResultMethods = {
  incrementVotes: (this: PollResultDocument, ...args: any[]) => any
  resetVotes: (this: PollResultDocument, ...args: any[]) => any
}

export type PollResultStatics = {
  getResultsForPoll: (this: PollResultModel, ...args: any[]) => any
  recordVote: (this: PollResultModel, ...args: any[]) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const PollResult = mongoose.model<PollResultDocument, PollResultModel>("PollResult", PollResultSchema);
 * ```
 */
export type PollResultModel = mongoose.Model<
  PollResultDocument,
  PollResultQueries
> &
  PollResultStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new PollResult schema instances:
 * ```
 * const PollResultSchema: PollResultSchema = new mongoose.Schema({ ... })
 * ```
 */
export type PollResultSchema = mongoose.Schema<
  PollResultDocument,
  PollResultModel,
  PollResultMethods,
  PollResultQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const PollResult = mongoose.model<PollResultDocument, PollResultModel>("PollResult", PollResultSchema);
 * ```
 */
export type PollResultDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  PollResultQueries
> &
  PollResultMethods & {
    pollId: PollDocument["_id"] | PollDocument
    optionId: PollDocument["_id"] | PollDocument
    votesCount?: number
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of PostDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `PostDocument.toObject()`. To avoid conflicts with model names, use the type alias `PostObject`.
 * ```
 * const postObject = post.toObject();
 * ```
 */
export type Post = {
  user: User["_id"] | User
  content: string
  likes: (User["_id"] | User)[]
  comments: (Comment["_id"] | Comment)[]
  isDeleted?: boolean
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
  likeCount: number
  commentCount: number
}

/**
 * Lean version of PostDocument (type alias of `Post`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Post } from "../models"
 * import { PostObject } from "../interfaces/mongoose.gen.ts"
 *
 * const postObject: PostObject = post.toObject();
 * ```
 */
export type PostObject = Post

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type PostQuery = mongoose.Query<any, PostDocument, PostQueries> &
  PostQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `PostSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type PostQueries = {}

export type PostMethods = {}

export type PostStatics = {
  addLike: (this: PostModel, ...args: any[]) => any
  removeLike: (this: PostModel, ...args: any[]) => any
  softDelete: (this: PostModel, ...args: any[]) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Post = mongoose.model<PostDocument, PostModel>("Post", PostSchema);
 * ```
 */
export type PostModel = mongoose.Model<PostDocument, PostQueries> & PostStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Post schema instances:
 * ```
 * const PostSchema: PostSchema = new mongoose.Schema({ ... })
 * ```
 */
export type PostSchema = mongoose.Schema<
  PostDocument,
  PostModel,
  PostMethods,
  PostQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Post = mongoose.model<PostDocument, PostModel>("Post", PostSchema);
 * ```
 */
export type PostDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  PostQueries
> &
  PostMethods & {
    user: UserDocument["_id"] | UserDocument
    content: string
    likes: mongoose.Types.Array<UserDocument["_id"] | UserDocument>
    comments: mongoose.Types.Array<CommentDocument["_id"] | CommentDocument>
    isDeleted?: boolean
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
    likeCount: number
    commentCount: number
  }

/**
 * Lean version of PrivateMessageDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `PrivateMessageDocument.toObject()`. To avoid conflicts with model names, use the type alias `PrivateMessageObject`.
 * ```
 * const privatemessageObject = privatemessage.toObject();
 * ```
 */
export type PrivateMessage = {
  sender: User["_id"] | User
  receiver: User["_id"] | User
  content: string
  isRead?: boolean
  isDeleted?: boolean
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
  isUnread: boolean
}

/**
 * Lean version of PrivateMessageDocument (type alias of `PrivateMessage`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { PrivateMessage } from "../models"
 * import { PrivateMessageObject } from "../interfaces/mongoose.gen.ts"
 *
 * const privatemessageObject: PrivateMessageObject = privatemessage.toObject();
 * ```
 */
export type PrivateMessageObject = PrivateMessage

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type PrivateMessageQuery = mongoose.Query<
  any,
  PrivateMessageDocument,
  PrivateMessageQueries
> &
  PrivateMessageQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `PrivateMessageSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type PrivateMessageQueries = {}

export type PrivateMessageMethods = {}

export type PrivateMessageStatics = {
  markAsRead: (this: PrivateMessageModel, ...args: any[]) => any
  softDelete: (this: PrivateMessageModel, ...args: any[]) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const PrivateMessage = mongoose.model<PrivateMessageDocument, PrivateMessageModel>("PrivateMessage", PrivateMessageSchema);
 * ```
 */
export type PrivateMessageModel = mongoose.Model<
  PrivateMessageDocument,
  PrivateMessageQueries
> &
  PrivateMessageStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new PrivateMessage schema instances:
 * ```
 * const PrivateMessageSchema: PrivateMessageSchema = new mongoose.Schema({ ... })
 * ```
 */
export type PrivateMessageSchema = mongoose.Schema<
  PrivateMessageDocument,
  PrivateMessageModel,
  PrivateMessageMethods,
  PrivateMessageQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const PrivateMessage = mongoose.model<PrivateMessageDocument, PrivateMessageModel>("PrivateMessage", PrivateMessageSchema);
 * ```
 */
export type PrivateMessageDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  PrivateMessageQueries
> &
  PrivateMessageMethods & {
    sender: UserDocument["_id"] | UserDocument
    receiver: UserDocument["_id"] | UserDocument
    content: string
    isRead?: boolean
    isDeleted?: boolean
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
    isUnread: boolean
  }

/**
 * Lean version of ProfileDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `ProfileDocument.toObject()`. To avoid conflicts with model names, use the type alias `ProfileObject`.
 * ```
 * const profileObject = profile.toObject();
 * ```
 */
export type Profile = {
  user: User["_id"] | User
  name: string
  email: string
  bio?: string
  profileImage?: string
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of ProfileDocument (type alias of `Profile`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Profile } from "../models"
 * import { ProfileObject } from "../interfaces/mongoose.gen.ts"
 *
 * const profileObject: ProfileObject = profile.toObject();
 * ```
 */
export type ProfileObject = Profile

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type ProfileQuery = mongoose.Query<
  any,
  ProfileDocument,
  ProfileQueries
> &
  ProfileQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `ProfileSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type ProfileQueries = {}

export type ProfileMethods = {
  updateProfile: (this: ProfileDocument, ...args: any[]) => any
}

export type ProfileStatics = {
  findByUserId: (this: ProfileModel, ...args: any[]) => any
  createOrUpdate: (this: ProfileModel, ...args: any[]) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Profile = mongoose.model<ProfileDocument, ProfileModel>("Profile", ProfileSchema);
 * ```
 */
export type ProfileModel = mongoose.Model<ProfileDocument, ProfileQueries> &
  ProfileStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Profile schema instances:
 * ```
 * const ProfileSchema: ProfileSchema = new mongoose.Schema({ ... })
 * ```
 */
export type ProfileSchema = mongoose.Schema<
  ProfileDocument,
  ProfileModel,
  ProfileMethods,
  ProfileQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Profile = mongoose.model<ProfileDocument, ProfileModel>("Profile", ProfileSchema);
 * ```
 */
export type ProfileDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  ProfileQueries
> &
  ProfileMethods & {
    user: UserDocument["_id"] | UserDocument
    name: string
    email: string
    bio?: string
    profileImage?: string
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of RedemptionDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `RedemptionDocument.toObject()`. To avoid conflicts with model names, use the type alias `RedemptionObject`.
 * ```
 * const redemptionObject = redemption.toObject();
 * ```
 */
export type Redemption = {
  user: User["_id"] | User
  pointsUsed: number
  item: string
  redemptionDate?: Date
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of RedemptionDocument (type alias of `Redemption`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Redemption } from "../models"
 * import { RedemptionObject } from "../interfaces/mongoose.gen.ts"
 *
 * const redemptionObject: RedemptionObject = redemption.toObject();
 * ```
 */
export type RedemptionObject = Redemption

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type RedemptionQuery = mongoose.Query<
  any,
  RedemptionDocument,
  RedemptionQueries
> &
  RedemptionQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `RedemptionSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type RedemptionQueries = {}

export type RedemptionMethods = {
  summarize: (this: RedemptionDocument, ...args: any[]) => any
}

export type RedemptionStatics = {
  findByUser: (this: RedemptionModel, ...args: any[]) => any
  findByDateRange: (this: RedemptionModel, ...args: any[]) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Redemption = mongoose.model<RedemptionDocument, RedemptionModel>("Redemption", RedemptionSchema);
 * ```
 */
export type RedemptionModel = mongoose.Model<
  RedemptionDocument,
  RedemptionQueries
> &
  RedemptionStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Redemption schema instances:
 * ```
 * const RedemptionSchema: RedemptionSchema = new mongoose.Schema({ ... })
 * ```
 */
export type RedemptionSchema = mongoose.Schema<
  RedemptionDocument,
  RedemptionModel,
  RedemptionMethods,
  RedemptionQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Redemption = mongoose.model<RedemptionDocument, RedemptionModel>("Redemption", RedemptionSchema);
 * ```
 */
export type RedemptionDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  RedemptionQueries
> &
  RedemptionMethods & {
    user: UserDocument["_id"] | UserDocument
    pointsUsed: number
    item: string
    redemptionDate?: Date
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of RefreshTokenDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `RefreshTokenDocument.toObject()`. To avoid conflicts with model names, use the type alias `RefreshTokenObject`.
 * ```
 * const refreshtokenObject = refreshtoken.toObject();
 * ```
 */
export type RefreshToken = {
  user: User["_id"] | User
  token: string
  expiresAt: Date
  revoked?: boolean
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
  isExpired: boolean
  isActive: boolean
}

/**
 * Lean version of RefreshTokenDocument (type alias of `RefreshToken`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { RefreshToken } from "../models"
 * import { RefreshTokenObject } from "../interfaces/mongoose.gen.ts"
 *
 * const refreshtokenObject: RefreshTokenObject = refreshtoken.toObject();
 * ```
 */
export type RefreshTokenObject = RefreshToken

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type RefreshTokenQuery = mongoose.Query<
  any,
  RefreshTokenDocument,
  RefreshTokenQueries
> &
  RefreshTokenQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `RefreshTokenSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type RefreshTokenQueries = {}

export type RefreshTokenMethods = {
  revoke: (this: RefreshTokenDocument, ...args: any[]) => any
}

export type RefreshTokenStatics = {
  generate: (this: RefreshTokenModel, ...args: any[]) => any
  findValid: (this: RefreshTokenModel, ...args: any[]) => any
  revokeToken: (this: RefreshTokenModel, ...args: any[]) => any
  removeExpired: (this: RefreshTokenModel, ...args: any[]) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const RefreshToken = mongoose.model<RefreshTokenDocument, RefreshTokenModel>("RefreshToken", RefreshTokenSchema);
 * ```
 */
export type RefreshTokenModel = mongoose.Model<
  RefreshTokenDocument,
  RefreshTokenQueries
> &
  RefreshTokenStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new RefreshToken schema instances:
 * ```
 * const RefreshTokenSchema: RefreshTokenSchema = new mongoose.Schema({ ... })
 * ```
 */
export type RefreshTokenSchema = mongoose.Schema<
  RefreshTokenDocument,
  RefreshTokenModel,
  RefreshTokenMethods,
  RefreshTokenQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const RefreshToken = mongoose.model<RefreshTokenDocument, RefreshTokenModel>("RefreshToken", RefreshTokenSchema);
 * ```
 */
export type RefreshTokenDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  RefreshTokenQueries
> &
  RefreshTokenMethods & {
    user: UserDocument["_id"] | UserDocument
    token: string
    expiresAt: Date
    revoked?: boolean
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
    isExpired: boolean
    isActive: boolean
  }

/**
 * Lean version of ReminderDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `ReminderDocument.toObject()`. To avoid conflicts with model names, use the type alias `ReminderObject`.
 * ```
 * const reminderObject = reminder.toObject();
 * ```
 */
export type Reminder = {
  user: User["_id"] | User
  message: string
  goal?: Goal["_id"] | Goal
  remindAt: Date
  recurrence?: "none" | "daily" | "weekly" | "monthly"
  isActive?: boolean
  isSent?: boolean
  reminderType?: "email" | "sms" | "app"
  email?: string
  lastSent?: Date
  endRepeat?: Date
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
  isRecurring: boolean
}

/**
 * Lean version of ReminderDocument (type alias of `Reminder`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Reminder } from "../models"
 * import { ReminderObject } from "../interfaces/mongoose.gen.ts"
 *
 * const reminderObject: ReminderObject = reminder.toObject();
 * ```
 */
export type ReminderObject = Reminder

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type ReminderQuery = mongoose.Query<
  any,
  ReminderDocument,
  ReminderQueries
> &
  ReminderQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `ReminderSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type ReminderQueries = {}

export type ReminderMethods = {
  deactivate: (this: ReminderDocument) => Promise<any>
  markAsSent: (this: ReminderDocument) => Promise<any>
}

export type ReminderStatics = {
  getUpcomingRemindersForUser: (
    this: ReminderModel,
    userId: mongoose.Types.ObjectId
  ) => any
  getUpcomingRemindersInRange: (
    this: ReminderModel,
    start: Date,
    end: Date
  ) => any
  getUserReminders: (
    this: ReminderModel,
    userId: mongoose.Types.ObjectId,
    filters?: {}
  ) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Reminder = mongoose.model<ReminderDocument, ReminderModel>("Reminder", ReminderSchema);
 * ```
 */
export type ReminderModel = mongoose.Model<ReminderDocument, ReminderQueries> &
  ReminderStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Reminder schema instances:
 * ```
 * const ReminderSchema: ReminderSchema = new mongoose.Schema({ ... })
 * ```
 */
export type ReminderSchema = mongoose.Schema<
  ReminderDocument,
  ReminderModel,
  ReminderMethods,
  ReminderQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Reminder = mongoose.model<ReminderDocument, ReminderModel>("Reminder", ReminderSchema);
 * ```
 */
export type ReminderDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  ReminderQueries
> &
  ReminderMethods & {
    user: UserDocument["_id"] | UserDocument
    message: string
    goal?: GoalDocument["_id"] | GoalDocument
    remindAt: Date
    recurrence?: "none" | "daily" | "weekly" | "monthly"
    isActive?: boolean
    isSent?: boolean
    reminderType?: "email" | "sms" | "app"
    email?: string
    lastSent?: Date
    endRepeat?: Date
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
    isRecurring: boolean
  }

/**
 * Lean version of ReportDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `ReportDocument.toObject()`. To avoid conflicts with model names, use the type alias `ReportObject`.
 * ```
 * const reportObject = report.toObject();
 * ```
 */
export type Report = {
  userId: User["_id"] | User
  reportedId: mongoose.Types.ObjectId
  reportType: "post" | "comment" | "user"
  reason: string
  status?: "pending" | "resolved"
  resolvedBy?: User["_id"] | User
  resolvedAt?: Date
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of ReportDocument (type alias of `Report`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Report } from "../models"
 * import { ReportObject } from "../interfaces/mongoose.gen.ts"
 *
 * const reportObject: ReportObject = report.toObject();
 * ```
 */
export type ReportObject = Report

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type ReportQuery = mongoose.Query<any, ReportDocument, ReportQueries> &
  ReportQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `ReportSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type ReportQueries = {}

export type ReportMethods = {
  resolve: (this: ReportDocument, ...args: any[]) => any
}

export type ReportStatics = {
  getByUser: (this: ReportModel, ...args: any[]) => any
  getPending: (this: ReportModel, ...args: any[]) => any
  resolveReport: (this: ReportModel, ...args: any[]) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Report = mongoose.model<ReportDocument, ReportModel>("Report", ReportSchema);
 * ```
 */
export type ReportModel = mongoose.Model<ReportDocument, ReportQueries> &
  ReportStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Report schema instances:
 * ```
 * const ReportSchema: ReportSchema = new mongoose.Schema({ ... })
 * ```
 */
export type ReportSchema = mongoose.Schema<
  ReportDocument,
  ReportModel,
  ReportMethods,
  ReportQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Report = mongoose.model<ReportDocument, ReportModel>("Report", ReportSchema);
 * ```
 */
export type ReportDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  ReportQueries
> &
  ReportMethods & {
    userId: UserDocument["_id"] | UserDocument
    reportedId: mongoose.Types.ObjectId
    reportType: "post" | "comment" | "user"
    reason: string
    status?: "pending" | "resolved"
    resolvedBy?: UserDocument["_id"] | UserDocument
    resolvedAt?: Date
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of ReviewDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `ReviewDocument.toObject()`. To avoid conflicts with model names, use the type alias `ReviewObject`.
 * ```
 * const reviewObject = review.toObject();
 * ```
 */
export type Review = {
  user: User["_id"] | User
  reviewedUser: User["_id"] | User
  rating: number
  comment?: string
  isAnonymous?: boolean
  flagged?: boolean
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of ReviewDocument (type alias of `Review`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Review } from "../models"
 * import { ReviewObject } from "../interfaces/mongoose.gen.ts"
 *
 * const reviewObject: ReviewObject = review.toObject();
 * ```
 */
export type ReviewObject = Review

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type ReviewQuery = mongoose.Query<any, ReviewDocument, ReviewQueries> &
  ReviewQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `ReviewSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type ReviewQueries = {}

export type ReviewMethods = {
  sanitizeComment: (this: ReviewDocument, ...args: any[]) => any
  markFlagged: (this: ReviewDocument, ...args: any[]) => any
}

export type ReviewStatics = {
  getReviewsForUser: (this: ReviewModel, ...args: any[]) => any
  flagReview: (this: ReviewModel, ...args: any[]) => any
  getAverageRating: (this: ReviewModel, ...args: any[]) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Review = mongoose.model<ReviewDocument, ReviewModel>("Review", ReviewSchema);
 * ```
 */
export type ReviewModel = mongoose.Model<ReviewDocument, ReviewQueries> &
  ReviewStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Review schema instances:
 * ```
 * const ReviewSchema: ReviewSchema = new mongoose.Schema({ ... })
 * ```
 */
export type ReviewSchema = mongoose.Schema<
  ReviewDocument,
  ReviewModel,
  ReviewMethods,
  ReviewQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Review = mongoose.model<ReviewDocument, ReviewModel>("Review", ReviewSchema);
 * ```
 */
export type ReviewDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  ReviewQueries
> &
  ReviewMethods & {
    user: UserDocument["_id"] | UserDocument
    reviewedUser: UserDocument["_id"] | UserDocument
    rating: number
    comment?: string
    isAnonymous?: boolean
    flagged?: boolean
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of RewardDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `RewardDocument.toObject()`. To avoid conflicts with model names, use the type alias `RewardObject`.
 * ```
 * const rewardObject = reward.toObject();
 * ```
 */
export type Reward = {
  name: string
  description: string
  pointsRequired: number
  rewardType: "badge" | "discount" | "giftCard" | "recognition"
  imageUrl?: string
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of RewardDocument (type alias of `Reward`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Reward } from "../models"
 * import { RewardObject } from "../interfaces/mongoose.gen.ts"
 *
 * const rewardObject: RewardObject = reward.toObject();
 * ```
 */
export type RewardObject = Reward

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type RewardQuery = mongoose.Query<any, RewardDocument, RewardQueries> &
  RewardQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `RewardSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type RewardQueries = {}

export type RewardMethods = {}

export type RewardStatics = {
  getAvailableRewards: (this: RewardModel, maxPoints: number) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Reward = mongoose.model<RewardDocument, RewardModel>("Reward", RewardSchema);
 * ```
 */
export type RewardModel = mongoose.Model<RewardDocument, RewardQueries> &
  RewardStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Reward schema instances:
 * ```
 * const RewardSchema: RewardSchema = new mongoose.Schema({ ... })
 * ```
 */
export type RewardSchema = mongoose.Schema<
  RewardDocument,
  RewardModel,
  RewardMethods,
  RewardQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Reward = mongoose.model<RewardDocument, RewardModel>("Reward", RewardSchema);
 * ```
 */
export type RewardDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  RewardQueries
> &
  RewardMethods & {
    name: string
    description: string
    pointsRequired: number
    rewardType: "badge" | "discount" | "giftCard" | "recognition"
    imageUrl?: string
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of RoleDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `RoleDocument.toObject()`. To avoid conflicts with model names, use the type alias `RoleObject`.
 * ```
 * const roleObject = role.toObject();
 * ```
 */
export type Role = {
  roleName: string
  permissions: string[]
  description?: string
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of RoleDocument (type alias of `Role`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Role } from "../models"
 * import { RoleObject } from "../interfaces/mongoose.gen.ts"
 *
 * const roleObject: RoleObject = role.toObject();
 * ```
 */
export type RoleObject = Role

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type RoleQuery = mongoose.Query<any, RoleDocument, RoleQueries> &
  RoleQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `RoleSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type RoleQueries = {}

export type RoleMethods = {
  hasPermission: (this: RoleDocument, ...args: any[]) => any
  addPermission: (this: RoleDocument, ...args: any[]) => any
  removePermission: (this: RoleDocument, ...args: any[]) => any
}

export type RoleStatics = {
  findByName: (this: RoleModel, ...args: any[]) => any
  getRolesWithPermission: (this: RoleModel, ...args: any[]) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Role = mongoose.model<RoleDocument, RoleModel>("Role", RoleSchema);
 * ```
 */
export type RoleModel = mongoose.Model<RoleDocument, RoleQueries> & RoleStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Role schema instances:
 * ```
 * const RoleSchema: RoleSchema = new mongoose.Schema({ ... })
 * ```
 */
export type RoleSchema = mongoose.Schema<
  RoleDocument,
  RoleModel,
  RoleMethods,
  RoleQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Role = mongoose.model<RoleDocument, RoleModel>("Role", RoleSchema);
 * ```
 */
export type RoleDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  RoleQueries
> &
  RoleMethods & {
    roleName: string
    permissions: mongoose.Types.Array<string>
    description?: string
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of RoomDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `RoomDocument.toObject()`. To avoid conflicts with model names, use the type alias `RoomObject`.
 * ```
 * const roomObject = room.toObject();
 * ```
 */
export type Room = {
  name: string
  description?: string
  isPrivate?: boolean
  createdBy: User["_id"] | User
  members: (User["_id"] | User)[]
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of RoomDocument (type alias of `Room`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Room } from "../models"
 * import { RoomObject } from "../interfaces/mongoose.gen.ts"
 *
 * const roomObject: RoomObject = room.toObject();
 * ```
 */
export type RoomObject = Room

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type RoomQuery = mongoose.Query<any, RoomDocument, RoomQueries> &
  RoomQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `RoomSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type RoomQueries = {}

export type RoomMethods = {
  addMember: (this: RoomDocument, ...args: any[]) => any
  removeMember: (this: RoomDocument, ...args: any[]) => any
  hasMember: (this: RoomDocument, ...args: any[]) => any
}

export type RoomStatics = {
  findByName: (this: RoomModel, ...args: any[]) => any
  findPublic: (this: RoomModel, ...args: any[]) => any
  findByUser: (this: RoomModel, ...args: any[]) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Room = mongoose.model<RoomDocument, RoomModel>("Room", RoomSchema);
 * ```
 */
export type RoomModel = mongoose.Model<RoomDocument, RoomQueries> & RoomStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Room schema instances:
 * ```
 * const RoomSchema: RoomSchema = new mongoose.Schema({ ... })
 * ```
 */
export type RoomSchema = mongoose.Schema<
  RoomDocument,
  RoomModel,
  RoomMethods,
  RoomQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Room = mongoose.model<RoomDocument, RoomModel>("Room", RoomSchema);
 * ```
 */
export type RoomDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  RoomQueries
> &
  RoomMethods & {
    name: string
    description?: string
    isPrivate?: boolean
    createdBy: UserDocument["_id"] | UserDocument
    members: mongoose.Types.Array<UserDocument["_id"] | UserDocument>
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of SessionDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `SessionDocument.toObject()`. To avoid conflicts with model names, use the type alias `SessionObject`.
 * ```
 * const sessionObject = session.toObject();
 * ```
 */
export type Session = {
  user: User["_id"] | User
  token: string
  ipAddress?: string
  device?: string
  userAgent?: string
  isActive?: boolean
  expiresAt: Date
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
  isExpired: boolean
}

/**
 * Lean version of SessionDocument (type alias of `Session`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Session } from "../models"
 * import { SessionObject } from "../interfaces/mongoose.gen.ts"
 *
 * const sessionObject: SessionObject = session.toObject();
 * ```
 */
export type SessionObject = Session

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type SessionQuery = mongoose.Query<
  any,
  SessionDocument,
  SessionQueries
> &
  SessionQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `SessionSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type SessionQueries = {}

export type SessionMethods = {
  invalidateSession: (this: SessionDocument, ...args: any[]) => any
}

export type SessionStatics = {
  invalidateUserSessions: (this: SessionModel, ...args: any[]) => any
  findActiveSessions: (this: SessionModel, ...args: any[]) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Session = mongoose.model<SessionDocument, SessionModel>("Session", SessionSchema);
 * ```
 */
export type SessionModel = mongoose.Model<SessionDocument, SessionQueries> &
  SessionStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Session schema instances:
 * ```
 * const SessionSchema: SessionSchema = new mongoose.Schema({ ... })
 * ```
 */
export type SessionSchema = mongoose.Schema<
  SessionDocument,
  SessionModel,
  SessionMethods,
  SessionQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Session = mongoose.model<SessionDocument, SessionModel>("Session", SessionSchema);
 * ```
 */
export type SessionDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  SessionQueries
> &
  SessionMethods & {
    user: UserDocument["_id"] | UserDocument
    token: string
    ipAddress?: string
    device?: string
    userAgent?: string
    isActive?: boolean
    expiresAt: Date
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
    isExpired: boolean
  }

/**
 * Lean version of StatisticsDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `StatisticsDocument.toObject()`. To avoid conflicts with model names, use the type alias `StatisticsObject`.
 * ```
 * const statisticsObject = statistics.toObject();
 * ```
 */
export type Statistics = {
  user: User["_id"] | User
  goalsCompleted?: number
  currentStreak?: number
  longestStreak?: number
  totalPoints?: number
  weeklyActivity?: Map<string, number>
  lastUpdated?: Date
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of StatisticsDocument (type alias of `Statistics`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Statistics } from "../models"
 * import { StatisticsObject } from "../interfaces/mongoose.gen.ts"
 *
 * const statisticsObject: StatisticsObject = statistics.toObject();
 * ```
 */
export type StatisticsObject = Statistics

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type StatisticsQuery = mongoose.Query<
  any,
  StatisticsDocument,
  StatisticsQueries
> &
  StatisticsQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `StatisticsSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type StatisticsQueries = {}

export type StatisticsMethods = {
  recordGoalCompletion: (this: StatisticsDocument, ...args: any[]) => any
  recordActivity: (this: StatisticsDocument, ...args: any[]) => any
  addPoints: (this: StatisticsDocument, ...args: any[]) => any
}

export type StatisticsStatics = {
  getByUser: (this: StatisticsModel, ...args: any[]) => any
  initializeForUser: (this: StatisticsModel, ...args: any[]) => any
  resetWeeklyActivity: (this: StatisticsModel, ...args: any[]) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Statistics = mongoose.model<StatisticsDocument, StatisticsModel>("Statistics", StatisticsSchema);
 * ```
 */
export type StatisticsModel = mongoose.Model<
  StatisticsDocument,
  StatisticsQueries
> &
  StatisticsStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Statistics schema instances:
 * ```
 * const StatisticsSchema: StatisticsSchema = new mongoose.Schema({ ... })
 * ```
 */
export type StatisticsSchema = mongoose.Schema<
  StatisticsDocument,
  StatisticsModel,
  StatisticsMethods,
  StatisticsQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Statistics = mongoose.model<StatisticsDocument, StatisticsModel>("Statistics", StatisticsSchema);
 * ```
 */
export type StatisticsDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  StatisticsQueries
> &
  StatisticsMethods & {
    user: UserDocument["_id"] | UserDocument
    goalsCompleted?: number
    currentStreak?: number
    longestStreak?: number
    totalPoints?: number
    weeklyActivity?: mongoose.Types.Map<number>
    lastUpdated?: Date
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of StreakDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `StreakDocument.toObject()`. To avoid conflicts with model names, use the type alias `StreakObject`.
 * ```
 * const streakObject = streak.toObject();
 * ```
 */
export type Streak = {
  user: User["_id"] | User
  streakCount?: number
  lastCheckIn?: Date | null
  longestStreak?: number
  checkInDates: Date[]
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of StreakDocument (type alias of `Streak`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Streak } from "../models"
 * import { StreakObject } from "../interfaces/mongoose.gen.ts"
 *
 * const streakObject: StreakObject = streak.toObject();
 * ```
 */
export type StreakObject = Streak

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type StreakQuery = mongoose.Query<any, StreakDocument, StreakQueries> &
  StreakQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `StreakSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type StreakQueries = {}

export type StreakMethods = {
  recordCheckIn: (this: StreakDocument) => Promise<StreakDocument>
  resetStreak: (this: StreakDocument) => Promise<StreakDocument>
}

export type StreakStatics = {}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Streak = mongoose.model<StreakDocument, StreakModel>("Streak", StreakSchema);
 * ```
 */
export type StreakModel = mongoose.Model<StreakDocument, StreakQueries> &
  StreakStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Streak schema instances:
 * ```
 * const StreakSchema: StreakSchema = new mongoose.Schema({ ... })
 * ```
 */
export type StreakSchema = mongoose.Schema<
  StreakDocument,
  StreakModel,
  StreakMethods,
  StreakQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Streak = mongoose.model<StreakDocument, StreakModel>("Streak", StreakSchema);
 * ```
 */
export type StreakDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  StreakQueries
> &
  StreakMethods & {
    user: UserDocument["_id"] | UserDocument
    streakCount?: number
    lastCheckIn?: Date | null
    longestStreak?: number
    checkInDates: mongoose.Types.Array<Date>
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of SupportTicketMessageDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `SupportTicketDocument.toObject()`.
 * ```
 * const supportticketObject = supportticket.toObject();
 * ```
 */
export type SupportTicketMessage = {
  sender: string
  content: string
  timestamp?: Date
}

/**
 * Lean version of SupportTicketDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `SupportTicketDocument.toObject()`. To avoid conflicts with model names, use the type alias `SupportTicketObject`.
 * ```
 * const supportticketObject = supportticket.toObject();
 * ```
 */
export type SupportTicket = {
  name: string
  email: string
  subject: string
  message: string
  priority?: "low" | "normal" | "high"
  status?: "open" | "pending" | "closed"
  messages: SupportTicketMessage[]
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of SupportTicketDocument (type alias of `SupportTicket`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { SupportTicket } from "../models"
 * import { SupportTicketObject } from "../interfaces/mongoose.gen.ts"
 *
 * const supportticketObject: SupportTicketObject = supportticket.toObject();
 * ```
 */
export type SupportTicketObject = SupportTicket

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type SupportTicketQuery = mongoose.Query<
  any,
  SupportTicketDocument,
  SupportTicketQueries
> &
  SupportTicketQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `SupportTicketSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type SupportTicketQueries = {}

export type SupportTicketMethods = {
  addMessage: (this: SupportTicketDocument, ...args: any[]) => any
  setStatus: (this: SupportTicketDocument, ...args: any[]) => any
}

export type SupportTicketStatics = {
  findByStatus: (this: SupportTicketModel, ...args: any[]) => any
  findByEmail: (this: SupportTicketModel, ...args: any[]) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const SupportTicket = mongoose.model<SupportTicketDocument, SupportTicketModel>("SupportTicket", SupportTicketSchema);
 * ```
 */
export type SupportTicketModel = mongoose.Model<
  SupportTicketDocument,
  SupportTicketQueries
> &
  SupportTicketStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new SupportTicket schema instances:
 * ```
 * const SupportTicketSchema: SupportTicketSchema = new mongoose.Schema({ ... })
 * ```
 */
export type SupportTicketSchema = mongoose.Schema<
  SupportTicketDocument,
  SupportTicketModel,
  SupportTicketMethods,
  SupportTicketQueries
>

/**
 * Mongoose Subdocument type
 *
 * Type of `SupportTicketDocument["messages"]` element.
 */
export type SupportTicketMessageDocument = mongoose.Types.Subdocument<any> & {
  sender: string
  content: string
  timestamp?: Date
}

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const SupportTicket = mongoose.model<SupportTicketDocument, SupportTicketModel>("SupportTicket", SupportTicketSchema);
 * ```
 */
export type SupportTicketDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  SupportTicketQueries
> &
  SupportTicketMethods & {
    name: string
    email: string
    subject: string
    message: string
    priority?: "low" | "normal" | "high"
    status?: "open" | "pending" | "closed"
    messages: mongoose.Types.DocumentArray<SupportTicketMessageDocument>
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of TaskDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `TaskDocument.toObject()`. To avoid conflicts with model names, use the type alias `TaskObject`.
 * ```
 * const taskObject = task.toObject();
 * ```
 */
export type Task = {
  user: User["_id"] | User
  title: string
  description?: string
  status?: "not-started" | "in-progress" | "completed" | "archived"
  dueDate?: Date
  completedAt?: Date
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of TaskDocument (type alias of `Task`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Task } from "../models"
 * import { TaskObject } from "../interfaces/mongoose.gen.ts"
 *
 * const taskObject: TaskObject = task.toObject();
 * ```
 */
export type TaskObject = Task

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type TaskQuery = mongoose.Query<any, TaskDocument, TaskQueries> &
  TaskQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `TaskSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type TaskQueries = {}

export type TaskMethods = {
  markComplete: (this: TaskDocument, ...args: any[]) => any
  archive: (this: TaskDocument, ...args: any[]) => any
  postpone: (this: TaskDocument, ...args: any[]) => any
}

export type TaskStatics = {
  getByUser: (this: TaskModel, ...args: any[]) => any
  getOverdue: (this: TaskModel, ...args: any[]) => any
  getUpcoming: (this: TaskModel, ...args: any[]) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Task = mongoose.model<TaskDocument, TaskModel>("Task", TaskSchema);
 * ```
 */
export type TaskModel = mongoose.Model<TaskDocument, TaskQueries> & TaskStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Task schema instances:
 * ```
 * const TaskSchema: TaskSchema = new mongoose.Schema({ ... })
 * ```
 */
export type TaskSchema = mongoose.Schema<
  TaskDocument,
  TaskModel,
  TaskMethods,
  TaskQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Task = mongoose.model<TaskDocument, TaskModel>("Task", TaskSchema);
 * ```
 */
export type TaskDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  TaskQueries
> &
  TaskMethods & {
    user: UserDocument["_id"] | UserDocument
    title: string
    description?: string
    status?: "not-started" | "in-progress" | "completed" | "archived"
    dueDate?: Date
    completedAt?: Date
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of TrackerDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `TrackerDocument.toObject()`. To avoid conflicts with model names, use the type alias `TrackerObject`.
 * ```
 * const trackerObject = tracker.toObject();
 * ```
 */
export type Tracker = {
  user: User["_id"] | User
  name: string
  progress: number
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of TrackerDocument (type alias of `Tracker`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Tracker } from "../models"
 * import { TrackerObject } from "../interfaces/mongoose.gen.ts"
 *
 * const trackerObject: TrackerObject = tracker.toObject();
 * ```
 */
export type TrackerObject = Tracker

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type TrackerQuery = mongoose.Query<
  any,
  TrackerDocument,
  TrackerQueries
> &
  TrackerQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `TrackerSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type TrackerQueries = {}

export type TrackerMethods = {
  addProgress: (this: TrackerDocument, ...args: any[]) => any
  reset: (this: TrackerDocument, ...args: any[]) => any
  isComplete: (this: TrackerDocument, ...args: any[]) => any
}

export type TrackerStatics = {
  findByUser: (this: TrackerModel, ...args: any[]) => any
  resetAll: (this: TrackerModel, ...args: any[]) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Tracker = mongoose.model<TrackerDocument, TrackerModel>("Tracker", TrackerSchema);
 * ```
 */
export type TrackerModel = mongoose.Model<TrackerDocument, TrackerQueries> &
  TrackerStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Tracker schema instances:
 * ```
 * const TrackerSchema: TrackerSchema = new mongoose.Schema({ ... })
 * ```
 */
export type TrackerSchema = mongoose.Schema<
  TrackerDocument,
  TrackerModel,
  TrackerMethods,
  TrackerQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Tracker = mongoose.model<TrackerDocument, TrackerModel>("Tracker", TrackerSchema);
 * ```
 */
export type TrackerDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  TrackerQueries
> &
  TrackerMethods & {
    user: UserDocument["_id"] | UserDocument
    name: string
    progress: number
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of UserDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `UserDocument.toObject()`. To avoid conflicts with model names, use the type alias `UserObject`.
 * ```
 * const userObject = user.toObject();
 * ```
 */
export type User = {
  username: string
  email: string
  password: string
  bio?: string
  profileImage?: string
  coverImage?: string
  name?: string
  role?: "user" | "admin" | "moderator" | "military"
  isVerified?: boolean
  permissions: string[]
  isLocked?: boolean
  active?: boolean
  friends: (User["_id"] | User)[]
  friendRequests: (User["_id"] | User)[]
  followers: (User["_id"] | User)[]
  following: (User["_id"] | User)[]
  rewards: (Reward["_id"] | Reward)[]
  achievements: (Achievement["_id"] | Achievement)[]
  badges: (Badge["_id"] | Badge)[]
  pinnedGoals: (Goal["_id"] | Goal)[]
  featuredAchievements: (Achievement["_id"] | Achievement)[]
  location: {
    country?: string
    state?: string
    city?: string
    timezone?: string
    coordinates: {
      latitude?: number
      longitude?: number
    }
  }
  stripeCustomerId?: string
  stripeSubscriptionId?: string
  subscription_status?: "trial" | "active" | "expired" | "canceled" | "past_due"
  subscriptionTier?: "free-trial" | "basic" | "pro" | "elite"
  trial_start_date?: Date
  trial_end_date?: Date
  subscriptionStartDate?: Date
  subscriptionEndDate?: Date
  next_billing_date?: Date
  billing_cycle?: "monthly" | "yearly"
  interests: string[]
  chatPreferences: {
    preferredGroups: (Chat["_id"] | Chat)[]
    directMessagesOnly?: boolean
  }
  activeStatus?: "online" | "offline"
  settings: {
    notifications: {
      email?: boolean
      sms?: boolean
    }
    privacy: {
      profileVisibility?: "public" | "friends" | "private"
    }
  }
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of UserDocument (type alias of `User`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { User } from "../models"
 * import { UserObject } from "../interfaces/mongoose.gen.ts"
 *
 * const userObject: UserObject = user.toObject();
 * ```
 */
export type UserObject = User

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type UserQuery = mongoose.Query<any, UserDocument, UserQueries> &
  UserQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `UserSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type UserQueries = {}

export type UserMethods = {
  hasFeatureAccess: (this: UserDocument, feature: string) => boolean
  isSubscriptionActive: (this: UserDocument) => boolean
  isInTrial: (this: UserDocument) => boolean
  getDaysUntilTrialEnd: (this: UserDocument) => number
  comparePassword: (
    this: UserDocument,
    candidatePassword: string
  ) => Promise<any>
  awardBadge: (
    this: UserDocument,
    badgeId: mongoose.Types.ObjectId
  ) => Promise<void>
  getGoalLimit: (this: UserDocument) => number
}

export type UserStatics = {}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const User = mongoose.model<UserDocument, UserModel>("User", UserSchema);
 * ```
 */
export type UserModel = mongoose.Model<UserDocument, UserQueries> & UserStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new User schema instances:
 * ```
 * const UserSchema: UserSchema = new mongoose.Schema({ ... })
 * ```
 */
export type UserSchema = mongoose.Schema<
  UserDocument,
  UserModel,
  UserMethods,
  UserQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const User = mongoose.model<UserDocument, UserModel>("User", UserSchema);
 * ```
 */
export type UserDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  UserQueries
> &
  UserMethods & {
    username: string
    email: string
    password: string
    bio?: string
    profileImage?: string
    coverImage?: string
    name?: string
    role?: "user" | "admin" | "moderator" | "military"
    isVerified?: boolean
    permissions: mongoose.Types.Array<string>
    isLocked?: boolean
    active?: boolean
    friends: mongoose.Types.Array<UserDocument["_id"] | UserDocument>
    friendRequests: mongoose.Types.Array<UserDocument["_id"] | UserDocument>
    followers: mongoose.Types.Array<UserDocument["_id"] | UserDocument>
    following: mongoose.Types.Array<UserDocument["_id"] | UserDocument>
    rewards: mongoose.Types.Array<RewardDocument["_id"] | RewardDocument>
    achievements: mongoose.Types.Array<
      AchievementDocument["_id"] | AchievementDocument
    >
    badges: mongoose.Types.Array<BadgeDocument["_id"] | BadgeDocument>
    pinnedGoals: mongoose.Types.Array<GoalDocument["_id"] | GoalDocument>
    featuredAchievements: mongoose.Types.Array<
      AchievementDocument["_id"] | AchievementDocument
    >
    location: {
      country?: string
      state?: string
      city?: string
      timezone?: string
      coordinates: {
        latitude?: number
        longitude?: number
      }
    }
    stripeCustomerId?: string
    stripeSubscriptionId?: string
    subscription_status?:
      | "trial"
      | "active"
      | "expired"
      | "canceled"
      | "past_due"
    subscriptionTier?: "free-trial" | "basic" | "pro" | "elite"
    trial_start_date?: Date
    trial_end_date?: Date
    subscriptionStartDate?: Date
    subscriptionEndDate?: Date
    next_billing_date?: Date
    billing_cycle?: "monthly" | "yearly"
    interests: mongoose.Types.Array<string>
    chatPreferences: {
      preferredGroups: mongoose.Types.Array<ChatDocument["_id"] | ChatDocument>
      directMessagesOnly?: boolean
    }
    activeStatus?: "online" | "offline"
    settings: {
      notifications: {
        email?: boolean
        sms?: boolean
      }
      privacy: {
        profileVisibility?: "public" | "friends" | "private"
      }
    }
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of UserProgressLogDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `UserProgressLogDocument.toObject()`. To avoid conflicts with model names, use the type alias `UserProgressLogObject`.
 * ```
 * const userprogresslogObject = userprogresslog.toObject();
 * ```
 */
export type UserProgressLog = {
  user: User["_id"] | User
  targetType: "goal" | "task" | "tracker"
  targetId: mongoose.Types.ObjectId
  before: number
  after: number
  note?: string
  _id: mongoose.Types.ObjectId
  createdAt?: Date
}

/**
 * Lean version of UserProgressLogDocument (type alias of `UserProgressLog`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { UserProgressLog } from "../models"
 * import { UserProgressLogObject } from "../interfaces/mongoose.gen.ts"
 *
 * const userprogresslogObject: UserProgressLogObject = userprogresslog.toObject();
 * ```
 */
export type UserProgressLogObject = UserProgressLog

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type UserProgressLogQuery = mongoose.Query<
  any,
  UserProgressLogDocument,
  UserProgressLogQueries
> &
  UserProgressLogQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `UserProgressLogSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type UserProgressLogQueries = {}

export type UserProgressLogMethods = {
  summary: (this: UserProgressLogDocument, ...args: any[]) => any
}

export type UserProgressLogStatics = {
  logProgress: (this: UserProgressLogModel, ...args: any[]) => any
  getByUser: (this: UserProgressLogModel, ...args: any[]) => any
  getByTarget: (this: UserProgressLogModel, ...args: any[]) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const UserProgressLog = mongoose.model<UserProgressLogDocument, UserProgressLogModel>("UserProgressLog", UserProgressLogSchema);
 * ```
 */
export type UserProgressLogModel = mongoose.Model<
  UserProgressLogDocument,
  UserProgressLogQueries
> &
  UserProgressLogStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new UserProgressLog schema instances:
 * ```
 * const UserProgressLogSchema: UserProgressLogSchema = new mongoose.Schema({ ... })
 * ```
 */
export type UserProgressLogSchema = mongoose.Schema<
  UserProgressLogDocument,
  UserProgressLogModel,
  UserProgressLogMethods,
  UserProgressLogQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const UserProgressLog = mongoose.model<UserProgressLogDocument, UserProgressLogModel>("UserProgressLog", UserProgressLogSchema);
 * ```
 */
export type UserProgressLogDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  UserProgressLogQueries
> &
  UserProgressLogMethods & {
    user: UserDocument["_id"] | UserDocument
    targetType: "goal" | "task" | "tracker"
    targetId: mongoose.Types.ObjectId
    before: number
    after: number
    note?: string
    _id: mongoose.Types.ObjectId
    createdAt?: Date
  }

/**
 * Lean version of VerificationTokenDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `VerificationTokenDocument.toObject()`. To avoid conflicts with model names, use the type alias `VerificationTokenObject`.
 * ```
 * const verificationtokenObject = verificationtoken.toObject();
 * ```
 */
export type VerificationToken = {
  user: User["_id"] | User
  token: string
  expiresAt: Date
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of VerificationTokenDocument (type alias of `VerificationToken`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { VerificationToken } from "../models"
 * import { VerificationTokenObject } from "../interfaces/mongoose.gen.ts"
 *
 * const verificationtokenObject: VerificationTokenObject = verificationtoken.toObject();
 * ```
 */
export type VerificationTokenObject = VerificationToken

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type VerificationTokenQuery = mongoose.Query<
  any,
  VerificationTokenDocument,
  VerificationTokenQueries
> &
  VerificationTokenQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `VerificationTokenSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type VerificationTokenQueries = {}

export type VerificationTokenMethods = {
  isExpired: (this: VerificationTokenDocument, ...args: any[]) => any
}

export type VerificationTokenStatics = {
  generate: (
    this: VerificationTokenModel,
    userId: mongoose.Types.ObjectId,
    expiresInSeconds?: number
  ) => Promise<VerificationTokenDocument>
  findValid: (
    this: VerificationTokenModel,
    token: string
  ) => Promise<VerificationTokenDocument | null>
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const VerificationToken = mongoose.model<VerificationTokenDocument, VerificationTokenModel>("VerificationToken", VerificationTokenSchema);
 * ```
 */
export type VerificationTokenModel = mongoose.Model<
  VerificationTokenDocument,
  VerificationTokenQueries
> &
  VerificationTokenStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new VerificationToken schema instances:
 * ```
 * const VerificationTokenSchema: VerificationTokenSchema = new mongoose.Schema({ ... })
 * ```
 */
export type VerificationTokenSchema = mongoose.Schema<
  VerificationTokenDocument,
  VerificationTokenModel,
  VerificationTokenMethods,
  VerificationTokenQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const VerificationToken = mongoose.model<VerificationTokenDocument, VerificationTokenModel>("VerificationToken", VerificationTokenSchema);
 * ```
 */
export type VerificationTokenDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  VerificationTokenQueries
> &
  VerificationTokenMethods & {
    user: UserDocument["_id"] | UserDocument
    token: string
    expiresAt: Date
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of XpHistoryDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `XpHistoryDocument.toObject()`. To avoid conflicts with model names, use the type alias `XpHistoryObject`.
 * ```
 * const xphistoryObject = xphistory.toObject();
 * ```
 */
export type XpHistory = {
  userId: User["_id"] | User
  xp: number
  date: Date
  reason: string
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of XpHistoryDocument (type alias of `XpHistory`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { XpHistory } from "../models"
 * import { XpHistoryObject } from "../interfaces/mongoose.gen.ts"
 *
 * const xphistoryObject: XpHistoryObject = xphistory.toObject();
 * ```
 */
export type XpHistoryObject = XpHistory

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type XpHistoryQuery = mongoose.Query<
  any,
  XpHistoryDocument,
  XpHistoryQueries
> &
  XpHistoryQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `XpHistorySchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type XpHistoryQueries = {}

export type XpHistoryMethods = {
  summary: (this: XpHistoryDocument, ...args: any[]) => any
}

export type XpHistoryStatics = {
  logXp: (this: XpHistoryModel, ...args: any[]) => any
  getForUser: (this: XpHistoryModel, ...args: any[]) => any
  getTotalXp: (this: XpHistoryModel, ...args: any[]) => any
}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const XpHistory = mongoose.model<XpHistoryDocument, XpHistoryModel>("XpHistory", XpHistorySchema);
 * ```
 */
export type XpHistoryModel = mongoose.Model<
  XpHistoryDocument,
  XpHistoryQueries
> &
  XpHistoryStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new XpHistory schema instances:
 * ```
 * const XpHistorySchema: XpHistorySchema = new mongoose.Schema({ ... })
 * ```
 */
export type XpHistorySchema = mongoose.Schema<
  XpHistoryDocument,
  XpHistoryModel,
  XpHistoryMethods,
  XpHistoryQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const XpHistory = mongoose.model<XpHistoryDocument, XpHistoryModel>("XpHistory", XpHistorySchema);
 * ```
 */
export type XpHistoryDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  XpHistoryQueries
> &
  XpHistoryMethods & {
    userId: UserDocument["_id"] | UserDocument
    xp: number
    date: Date
    reason: string
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Check if a property on a document is populated:
 * ```
 * import { IsPopulated } from "../interfaces/mongoose.gen.ts"
 *
 * if (IsPopulated<UserDocument["bestFriend"]>) { ... }
 * ```
 */
export function IsPopulated<T>(doc: T | mongoose.Types.ObjectId): doc is T {
  return doc instanceof mongoose.Document
}

/**
 * Helper type used by `PopulatedDocument`. Returns the parent property of a string
 * representing a nested property (i.e. `friend.user` -> `friend`)
 */
type ParentProperty<T> = T extends `${infer P}.${string}` ? P : never

/**
 * Helper type used by `PopulatedDocument`. Returns the child property of a string
 * representing a nested property (i.e. `friend.user` -> `user`).
 */
type ChildProperty<T> = T extends `${string}.${infer C}` ? C : never

/**
 * Helper type used by `PopulatedDocument`. Removes the `ObjectId` from the general union type generated
 * for ref documents (i.e. `mongoose.Types.ObjectId | UserDocument` -> `UserDocument`)
 */
type PopulatedProperty<Root, T extends keyof Root> = Omit<Root, T> & {
  [ref in T]: Root[T] extends mongoose.Types.Array<infer U>
    ? mongoose.Types.Array<Exclude<U, mongoose.Types.ObjectId>>
    : Exclude<Root[T], mongoose.Types.ObjectId>
}

/**
 * Populate properties on a document type:
 * ```
 * import { PopulatedDocument } from "../interfaces/mongoose.gen.ts"
 *
 * function example(user: PopulatedDocument<UserDocument, "bestFriend">) {
 *   console.log(user.bestFriend._id) // typescript knows this is populated
 * }
 * ```
 */
export type PopulatedDocument<DocType, T> = T extends keyof DocType
  ? PopulatedProperty<DocType, T>
  : ParentProperty<T> extends keyof DocType
  ? Omit<DocType, ParentProperty<T>> & {
      [ref in ParentProperty<T>]: DocType[ParentProperty<T>] extends mongoose.Types.Array<
        infer U
      >
        ? mongoose.Types.Array<
            ChildProperty<T> extends keyof U
              ? PopulatedProperty<U, ChildProperty<T>>
              : PopulatedDocument<U, ChildProperty<T>>
          >
        : ChildProperty<T> extends keyof DocType[ParentProperty<T>]
        ? PopulatedProperty<DocType[ParentProperty<T>], ChildProperty<T>>
        : PopulatedDocument<DocType[ParentProperty<T>], ChildProperty<T>>
    }
  : DocType

/**
 * Helper types used by the populate overloads
 */
type Unarray<T> = T extends Array<infer U> ? U : T
type Modify<T, R> = Omit<T, keyof R> & R

/**
 * Augment mongoose with Query.populate overloads
 */
declare module "mongoose" {
  interface Query<ResultType, DocType, THelpers = {}> {
    populate<T extends string>(
      path: T,
      select?: string | any,
      model?: string | Model<any, THelpers>,
      match?: any
    ): Query<
      ResultType extends Array<DocType>
        ? Array<PopulatedDocument<Unarray<ResultType>, T>>
        : ResultType extends DocType
        ? PopulatedDocument<Unarray<ResultType>, T>
        : ResultType,
      DocType,
      THelpers
    > &
      THelpers

    populate<T extends string>(
      options: Modify<PopulateOptions, { path: T }> | Array<PopulateOptions>
    ): Query<
      ResultType extends Array<DocType>
        ? Array<PopulatedDocument<Unarray<ResultType>, T>>
        : ResultType extends DocType
        ? PopulatedDocument<Unarray<ResultType>, T>
        : ResultType,
      DocType,
      THelpers
    > &
      THelpers
  }
}
